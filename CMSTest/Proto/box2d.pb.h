// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: box2d.proto

#ifndef PROTOBUF_box2d_2eproto__INCLUDED
#define PROTOBUF_box2d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_box2d_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPbVec2Impl();
void InitDefaultsPbVec2();
void InitDefaultsPbFilterImpl();
void InitDefaultsPbFilter();
void InitDefaultsPbShapeImpl();
void InitDefaultsPbShape();
void InitDefaultsPbFixtureImpl();
void InitDefaultsPbFixture();
void InitDefaultsPbJointImpl();
void InitDefaultsPbJoint();
void InitDefaultsPbBodyImpl();
void InitDefaultsPbBody();
void InitDefaultsPbWorldImpl();
void InitDefaultsPbWorld();
inline void InitDefaults() {
  InitDefaultsPbVec2();
  InitDefaultsPbFilter();
  InitDefaultsPbShape();
  InitDefaultsPbFixture();
  InitDefaultsPbJoint();
  InitDefaultsPbBody();
  InitDefaultsPbWorld();
}
}  // namespace protobuf_box2d_2eproto
namespace box2d {
class PbBody;
class PbBodyDefaultTypeInternal;
extern PbBodyDefaultTypeInternal _PbBody_default_instance_;
class PbFilter;
class PbFilterDefaultTypeInternal;
extern PbFilterDefaultTypeInternal _PbFilter_default_instance_;
class PbFixture;
class PbFixtureDefaultTypeInternal;
extern PbFixtureDefaultTypeInternal _PbFixture_default_instance_;
class PbJoint;
class PbJointDefaultTypeInternal;
extern PbJointDefaultTypeInternal _PbJoint_default_instance_;
class PbShape;
class PbShapeDefaultTypeInternal;
extern PbShapeDefaultTypeInternal _PbShape_default_instance_;
class PbVec2;
class PbVec2DefaultTypeInternal;
extern PbVec2DefaultTypeInternal _PbVec2_default_instance_;
class PbWorld;
class PbWorldDefaultTypeInternal;
extern PbWorldDefaultTypeInternal _PbWorld_default_instance_;
}  // namespace box2d
namespace box2d {

enum PbBodyType {
  STATIC = 0,
  DYNAMIC = 1,
  KINEMATIC = 2
};
bool PbBodyType_IsValid(int value);
const PbBodyType PbBodyType_MIN = STATIC;
const PbBodyType PbBodyType_MAX = KINEMATIC;
const int PbBodyType_ARRAYSIZE = PbBodyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbBodyType_descriptor();
inline const ::std::string& PbBodyType_Name(PbBodyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbBodyType_descriptor(), value);
}
inline bool PbBodyType_Parse(
    const ::std::string& name, PbBodyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbBodyType>(
    PbBodyType_descriptor(), name, value);
}
enum PbShapeType {
  CIRCLE = 1,
  POLYGON = 2,
  EDGE = 3,
  LOOP = 4
};
bool PbShapeType_IsValid(int value);
const PbShapeType PbShapeType_MIN = CIRCLE;
const PbShapeType PbShapeType_MAX = LOOP;
const int PbShapeType_ARRAYSIZE = PbShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbShapeType_descriptor();
inline const ::std::string& PbShapeType_Name(PbShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbShapeType_descriptor(), value);
}
inline bool PbShapeType_Parse(
    const ::std::string& name, PbShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbShapeType>(
    PbShapeType_descriptor(), name, value);
}
enum PbJointType {
  DISTANCE = 1,
  REVOLUTE = 2,
  PRISMATIC = 3,
  PULLEY = 4,
  MOUSE = 5,
  GEAR = 6,
  WHEEL = 7,
  WELD = 8,
  FRICTION = 9,
  ROPE = 10,
  CONSTANT_VOLUME = 11,
  LINE = 12
};
bool PbJointType_IsValid(int value);
const PbJointType PbJointType_MIN = DISTANCE;
const PbJointType PbJointType_MAX = LINE;
const int PbJointType_ARRAYSIZE = PbJointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbJointType_descriptor();
inline const ::std::string& PbJointType_Name(PbJointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbJointType_descriptor(), value);
}
inline bool PbJointType_Parse(
    const ::std::string& name, PbJointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbJointType>(
    PbJointType_descriptor(), name, value);
}
// ===================================================================

class PbVec2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbVec2) */ {
 public:
  PbVec2();
  virtual ~PbVec2();

  PbVec2(const PbVec2& from);

  inline PbVec2& operator=(const PbVec2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbVec2(PbVec2&& from) noexcept
    : PbVec2() {
    *this = ::std::move(from);
  }

  inline PbVec2& operator=(PbVec2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbVec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbVec2* internal_default_instance() {
    return reinterpret_cast<const PbVec2*>(
               &_PbVec2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PbVec2* other);
  friend void swap(PbVec2& a, PbVec2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbVec2* New() const PROTOBUF_FINAL { return New(NULL); }

  PbVec2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbVec2& from);
  void MergeFrom(const PbVec2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbVec2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:box2d.PbVec2)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbVec2Impl();
};
// -------------------------------------------------------------------

class PbFilter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbFilter) */ {
 public:
  PbFilter();
  virtual ~PbFilter();

  PbFilter(const PbFilter& from);

  inline PbFilter& operator=(const PbFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbFilter(PbFilter&& from) noexcept
    : PbFilter() {
    *this = ::std::move(from);
  }

  inline PbFilter& operator=(PbFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbFilter* internal_default_instance() {
    return reinterpret_cast<const PbFilter*>(
               &_PbFilter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PbFilter* other);
  friend void swap(PbFilter& a, PbFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbFilter* New() const PROTOBUF_FINAL { return New(NULL); }

  PbFilter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbFilter& from);
  void MergeFrom(const PbFilter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 category_bits = 1;
  bool has_category_bits() const;
  void clear_category_bits();
  static const int kCategoryBitsFieldNumber = 1;
  ::google::protobuf::int32 category_bits() const;
  void set_category_bits(::google::protobuf::int32 value);

  // optional int32 mask_bits = 2;
  bool has_mask_bits() const;
  void clear_mask_bits();
  static const int kMaskBitsFieldNumber = 2;
  ::google::protobuf::int32 mask_bits() const;
  void set_mask_bits(::google::protobuf::int32 value);

  // optional int32 group_index = 3;
  bool has_group_index() const;
  void clear_group_index();
  static const int kGroupIndexFieldNumber = 3;
  ::google::protobuf::int32 group_index() const;
  void set_group_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:box2d.PbFilter)
 private:
  void set_has_category_bits();
  void clear_has_category_bits();
  void set_has_mask_bits();
  void clear_has_mask_bits();
  void set_has_group_index();
  void clear_has_group_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 category_bits_;
  ::google::protobuf::int32 mask_bits_;
  ::google::protobuf::int32 group_index_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbFilterImpl();
};
// -------------------------------------------------------------------

class PbShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbShape) */ {
 public:
  PbShape();
  virtual ~PbShape();

  PbShape(const PbShape& from);

  inline PbShape& operator=(const PbShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbShape(PbShape&& from) noexcept
    : PbShape() {
    *this = ::std::move(from);
  }

  inline PbShape& operator=(PbShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbShape* internal_default_instance() {
    return reinterpret_cast<const PbShape*>(
               &_PbShape_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PbShape* other);
  friend void swap(PbShape& a, PbShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbShape* New() const PROTOBUF_FINAL { return New(NULL); }

  PbShape* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbShape& from);
  void MergeFrom(const PbShape& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .box2d.PbVec2 points = 20;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 20;
  const ::box2d::PbVec2& points(int index) const;
  ::box2d::PbVec2* mutable_points(int index);
  ::box2d::PbVec2* add_points();
  ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
      points() const;

  // repeated .box2d.PbVec2 normals = 21;
  int normals_size() const;
  void clear_normals();
  static const int kNormalsFieldNumber = 21;
  const ::box2d::PbVec2& normals(int index) const;
  ::box2d::PbVec2* mutable_normals(int index);
  ::box2d::PbVec2* add_normals();
  ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
      mutable_normals();
  const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
      normals() const;

  // optional .box2d.PbVec2 center = 10;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 10;
  const ::box2d::PbVec2& center() const;
  ::box2d::PbVec2* release_center();
  ::box2d::PbVec2* mutable_center();
  void set_allocated_center(::box2d::PbVec2* center);

  // optional .box2d.PbVec2 centroid = 22;
  bool has_centroid() const;
  void clear_centroid();
  static const int kCentroidFieldNumber = 22;
  const ::box2d::PbVec2& centroid() const;
  ::box2d::PbVec2* release_centroid();
  ::box2d::PbVec2* mutable_centroid();
  void set_allocated_centroid(::box2d::PbVec2* centroid);

  // optional int64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::int64 tag() const;
  void set_tag(::google::protobuf::int64 value);

  // optional float radius = 11;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 11;
  float radius() const;
  void set_radius(float value);

  // required .box2d.PbShapeType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::box2d::PbShapeType type() const;
  void set_type(::box2d::PbShapeType value);

  // @@protoc_insertion_point(class_scope:box2d.PbShape)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_type();
  void clear_has_type();
  void set_has_center();
  void clear_has_center();
  void set_has_radius();
  void clear_has_radius();
  void set_has_centroid();
  void clear_has_centroid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 > points_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 > normals_;
  ::box2d::PbVec2* center_;
  ::box2d::PbVec2* centroid_;
  ::google::protobuf::int64 tag_;
  float radius_;
  int type_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbShapeImpl();
};
// -------------------------------------------------------------------

class PbFixture : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbFixture) */ {
 public:
  PbFixture();
  virtual ~PbFixture();

  PbFixture(const PbFixture& from);

  inline PbFixture& operator=(const PbFixture& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbFixture(PbFixture&& from) noexcept
    : PbFixture() {
    *this = ::std::move(from);
  }

  inline PbFixture& operator=(PbFixture&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbFixture& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbFixture* internal_default_instance() {
    return reinterpret_cast<const PbFixture*>(
               &_PbFixture_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PbFixture* other);
  friend void swap(PbFixture& a, PbFixture& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbFixture* New() const PROTOBUF_FINAL { return New(NULL); }

  PbFixture* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbFixture& from);
  void MergeFrom(const PbFixture& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbFixture* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .box2d.PbFilter filter = 10;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 10;
  const ::box2d::PbFilter& filter() const;
  ::box2d::PbFilter* release_filter();
  ::box2d::PbFilter* mutable_filter();
  void set_allocated_filter(::box2d::PbFilter* filter);

  // optional .box2d.PbShape shape = 11;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 11;
  const ::box2d::PbShape& shape() const;
  ::box2d::PbShape* release_shape();
  ::box2d::PbShape* mutable_shape();
  void set_allocated_shape(::box2d::PbShape* shape);

  // optional int64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::int64 tag() const;
  void set_tag(::google::protobuf::int64 value);

  // optional float restitution = 2;
  bool has_restitution() const;
  void clear_restitution();
  static const int kRestitutionFieldNumber = 2;
  float restitution() const;
  void set_restitution(float value);

  // optional float friction = 3;
  bool has_friction() const;
  void clear_friction();
  static const int kFrictionFieldNumber = 3;
  float friction() const;
  void set_friction(float value);

  // optional float density = 4;
  bool has_density() const;
  void clear_density();
  static const int kDensityFieldNumber = 4;
  float density() const;
  void set_density(float value);

  // optional bool sensor = 5;
  bool has_sensor() const;
  void clear_sensor();
  static const int kSensorFieldNumber = 5;
  bool sensor() const;
  void set_sensor(bool value);

  // @@protoc_insertion_point(class_scope:box2d.PbFixture)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_restitution();
  void clear_has_restitution();
  void set_has_friction();
  void clear_has_friction();
  void set_has_density();
  void clear_has_density();
  void set_has_sensor();
  void clear_has_sensor();
  void set_has_filter();
  void clear_has_filter();
  void set_has_shape();
  void clear_has_shape();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::box2d::PbFilter* filter_;
  ::box2d::PbShape* shape_;
  ::google::protobuf::int64 tag_;
  float restitution_;
  float friction_;
  float density_;
  bool sensor_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbFixtureImpl();
};
// -------------------------------------------------------------------

class PbJoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbJoint) */ {
 public:
  PbJoint();
  virtual ~PbJoint();

  PbJoint(const PbJoint& from);

  inline PbJoint& operator=(const PbJoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbJoint(PbJoint&& from) noexcept
    : PbJoint() {
    *this = ::std::move(from);
  }

  inline PbJoint& operator=(PbJoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbJoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbJoint* internal_default_instance() {
    return reinterpret_cast<const PbJoint*>(
               &_PbJoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(PbJoint* other);
  friend void swap(PbJoint& a, PbJoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbJoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PbJoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbJoint& from);
  void MergeFrom(const PbJoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbJoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 bodies = 110;
  int bodies_size() const;
  void clear_bodies();
  static const int kBodiesFieldNumber = 110;
  ::google::protobuf::int32 bodies(int index) const;
  void set_bodies(int index, ::google::protobuf::int32 value);
  void add_bodies(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bodies() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bodies();

  // repeated int32 joints = 111;
  int joints_size() const;
  void clear_joints();
  static const int kJointsFieldNumber = 111;
  ::google::protobuf::int32 joints(int index) const;
  void set_joints(int index, ::google::protobuf::int32 value);
  void add_joints(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      joints() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_joints();

  // optional .box2d.PbVec2 local_anchor_a = 6;
  bool has_local_anchor_a() const;
  void clear_local_anchor_a();
  static const int kLocalAnchorAFieldNumber = 6;
  const ::box2d::PbVec2& local_anchor_a() const;
  ::box2d::PbVec2* release_local_anchor_a();
  ::box2d::PbVec2* mutable_local_anchor_a();
  void set_allocated_local_anchor_a(::box2d::PbVec2* local_anchor_a);

  // optional .box2d.PbVec2 local_anchor_b = 7;
  bool has_local_anchor_b() const;
  void clear_local_anchor_b();
  static const int kLocalAnchorBFieldNumber = 7;
  const ::box2d::PbVec2& local_anchor_b() const;
  ::box2d::PbVec2* release_local_anchor_b();
  ::box2d::PbVec2* mutable_local_anchor_b();
  void set_allocated_local_anchor_b(::box2d::PbVec2* local_anchor_b);

  // optional .box2d.PbVec2 local_axis_a = 20;
  bool has_local_axis_a() const;
  void clear_local_axis_a();
  static const int kLocalAxisAFieldNumber = 20;
  const ::box2d::PbVec2& local_axis_a() const;
  ::box2d::PbVec2* release_local_axis_a();
  ::box2d::PbVec2* mutable_local_axis_a();
  void set_allocated_local_axis_a(::box2d::PbVec2* local_axis_a);

  // optional .box2d.PbVec2 ground_anchor_a = 40;
  bool has_ground_anchor_a() const;
  void clear_ground_anchor_a();
  static const int kGroundAnchorAFieldNumber = 40;
  const ::box2d::PbVec2& ground_anchor_a() const;
  ::box2d::PbVec2* release_ground_anchor_a();
  ::box2d::PbVec2* mutable_ground_anchor_a();
  void set_allocated_ground_anchor_a(::box2d::PbVec2* ground_anchor_a);

  // optional .box2d.PbVec2 ground_anchor_b = 41;
  bool has_ground_anchor_b() const;
  void clear_ground_anchor_b();
  static const int kGroundAnchorBFieldNumber = 41;
  const ::box2d::PbVec2& ground_anchor_b() const;
  ::box2d::PbVec2* release_ground_anchor_b();
  ::box2d::PbVec2* mutable_ground_anchor_b();
  void set_allocated_ground_anchor_b(::box2d::PbVec2* ground_anchor_b);

  // optional .box2d.PbVec2 target = 50;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 50;
  const ::box2d::PbVec2& target() const;
  ::box2d::PbVec2* release_target();
  ::box2d::PbVec2* mutable_target();
  void set_allocated_target(::box2d::PbVec2* target);

  // optional int64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::int64 tag() const;
  void set_tag(::google::protobuf::int64 value);

  // optional int32 body_a = 3;
  bool has_body_a() const;
  void clear_body_a();
  static const int kBodyAFieldNumber = 3;
  ::google::protobuf::int32 body_a() const;
  void set_body_a(::google::protobuf::int32 value);

  // optional int32 body_b = 4;
  bool has_body_b() const;
  void clear_body_b();
  static const int kBodyBFieldNumber = 4;
  ::google::protobuf::int32 body_b() const;
  void set_body_b(::google::protobuf::int32 value);

  // optional float ref_angle = 10;
  bool has_ref_angle() const;
  void clear_ref_angle();
  static const int kRefAngleFieldNumber = 10;
  float ref_angle() const;
  void set_ref_angle(float value);

  // optional bool collideConnected = 5;
  bool has_collideconnected() const;
  void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 5;
  bool collideconnected() const;
  void set_collideconnected(bool value);

  // optional bool enable_limit = 12;
  bool has_enable_limit() const;
  void clear_enable_limit();
  static const int kEnableLimitFieldNumber = 12;
  bool enable_limit() const;
  void set_enable_limit(bool value);

  // optional bool enable_motor = 15;
  bool has_enable_motor() const;
  void clear_enable_motor();
  static const int kEnableMotorFieldNumber = 15;
  bool enable_motor() const;
  void set_enable_motor(bool value);

  // optional float lower_limit = 13;
  bool has_lower_limit() const;
  void clear_lower_limit();
  static const int kLowerLimitFieldNumber = 13;
  float lower_limit() const;
  void set_lower_limit(float value);

  // optional float upper_limit = 14;
  bool has_upper_limit() const;
  void clear_upper_limit();
  static const int kUpperLimitFieldNumber = 14;
  float upper_limit() const;
  void set_upper_limit(float value);

  // optional float motor_speed = 16;
  bool has_motor_speed() const;
  void clear_motor_speed();
  static const int kMotorSpeedFieldNumber = 16;
  float motor_speed() const;
  void set_motor_speed(float value);

  // optional float max_motor_torque = 17;
  bool has_max_motor_torque() const;
  void clear_max_motor_torque();
  static const int kMaxMotorTorqueFieldNumber = 17;
  float max_motor_torque() const;
  void set_max_motor_torque(float value);

  // optional float max_motor_force = 21;
  bool has_max_motor_force() const;
  void clear_max_motor_force();
  static const int kMaxMotorForceFieldNumber = 21;
  float max_motor_force() const;
  void set_max_motor_force(float value);

  // optional float length = 30;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 30;
  float length() const;
  void set_length(float value);

  // optional float frequency = 31;
  bool has_frequency() const;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 31;
  float frequency() const;
  void set_frequency(float value);

  // optional float damping_ratio = 32;
  bool has_damping_ratio() const;
  void clear_damping_ratio();
  static const int kDampingRatioFieldNumber = 32;
  float damping_ratio() const;
  void set_damping_ratio(float value);

  // optional float target_volume = 112;
  bool has_target_volume() const;
  void clear_target_volume();
  static const int kTargetVolumeFieldNumber = 112;
  float target_volume() const;
  void set_target_volume(float value);

  // optional float length_a = 42;
  bool has_length_a() const;
  void clear_length_a();
  static const int kLengthAFieldNumber = 42;
  float length_a() const;
  void set_length_a(float value);

  // optional float length_b = 43;
  bool has_length_b() const;
  void clear_length_b();
  static const int kLengthBFieldNumber = 43;
  float length_b() const;
  void set_length_b(float value);

  // optional float ratio = 44;
  bool has_ratio() const;
  void clear_ratio();
  static const int kRatioFieldNumber = 44;
  float ratio() const;
  void set_ratio(float value);

  // optional float max_length_a = 45;
  bool has_max_length_a() const;
  void clear_max_length_a();
  static const int kMaxLengthAFieldNumber = 45;
  float max_length_a() const;
  void set_max_length_a(float value);

  // optional float max_length_b = 46;
  bool has_max_length_b() const;
  void clear_max_length_b();
  static const int kMaxLengthBFieldNumber = 46;
  float max_length_b() const;
  void set_max_length_b(float value);

  // optional float max_force = 51;
  bool has_max_force() const;
  void clear_max_force();
  static const int kMaxForceFieldNumber = 51;
  float max_force() const;
  void set_max_force(float value);

  // optional int32 joint1 = 61;
  bool has_joint1() const;
  void clear_joint1();
  static const int kJoint1FieldNumber = 61;
  ::google::protobuf::int32 joint1() const;
  void set_joint1(::google::protobuf::int32 value);

  // optional int32 joint2 = 62;
  bool has_joint2() const;
  void clear_joint2();
  static const int kJoint2FieldNumber = 62;
  ::google::protobuf::int32 joint2() const;
  void set_joint2(::google::protobuf::int32 value);

  // optional float spring_frequency = 70;
  bool has_spring_frequency() const;
  void clear_spring_frequency();
  static const int kSpringFrequencyFieldNumber = 70;
  float spring_frequency() const;
  void set_spring_frequency(float value);

  // optional float spring_damping_ratio = 71;
  bool has_spring_damping_ratio() const;
  void clear_spring_damping_ratio();
  static const int kSpringDampingRatioFieldNumber = 71;
  float spring_damping_ratio() const;
  void set_spring_damping_ratio(float value);

  // optional float max_torque = 90;
  bool has_max_torque() const;
  void clear_max_torque();
  static const int kMaxTorqueFieldNumber = 90;
  float max_torque() const;
  void set_max_torque(float value);

  // optional float max_length = 100;
  bool has_max_length() const;
  void clear_max_length();
  static const int kMaxLengthFieldNumber = 100;
  float max_length() const;
  void set_max_length(float value);

  // required .box2d.PbJointType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::box2d::PbJointType type() const;
  void set_type(::box2d::PbJointType value);

  // @@protoc_insertion_point(class_scope:box2d.PbJoint)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_type();
  void clear_has_type();
  void set_has_body_a();
  void clear_has_body_a();
  void set_has_body_b();
  void clear_has_body_b();
  void set_has_collideconnected();
  void clear_has_collideconnected();
  void set_has_local_anchor_a();
  void clear_has_local_anchor_a();
  void set_has_local_anchor_b();
  void clear_has_local_anchor_b();
  void set_has_ref_angle();
  void clear_has_ref_angle();
  void set_has_enable_limit();
  void clear_has_enable_limit();
  void set_has_lower_limit();
  void clear_has_lower_limit();
  void set_has_upper_limit();
  void clear_has_upper_limit();
  void set_has_enable_motor();
  void clear_has_enable_motor();
  void set_has_motor_speed();
  void clear_has_motor_speed();
  void set_has_max_motor_torque();
  void clear_has_max_motor_torque();
  void set_has_local_axis_a();
  void clear_has_local_axis_a();
  void set_has_max_motor_force();
  void clear_has_max_motor_force();
  void set_has_length();
  void clear_has_length();
  void set_has_frequency();
  void clear_has_frequency();
  void set_has_damping_ratio();
  void clear_has_damping_ratio();
  void set_has_ground_anchor_a();
  void clear_has_ground_anchor_a();
  void set_has_ground_anchor_b();
  void clear_has_ground_anchor_b();
  void set_has_length_a();
  void clear_has_length_a();
  void set_has_length_b();
  void clear_has_length_b();
  void set_has_ratio();
  void clear_has_ratio();
  void set_has_max_length_a();
  void clear_has_max_length_a();
  void set_has_max_length_b();
  void clear_has_max_length_b();
  void set_has_target();
  void clear_has_target();
  void set_has_max_force();
  void clear_has_max_force();
  void set_has_joint1();
  void clear_has_joint1();
  void set_has_joint2();
  void clear_has_joint2();
  void set_has_spring_frequency();
  void clear_has_spring_frequency();
  void set_has_spring_damping_ratio();
  void clear_has_spring_damping_ratio();
  void set_has_max_torque();
  void clear_has_max_torque();
  void set_has_max_length();
  void clear_has_max_length();
  void set_has_target_volume();
  void clear_has_target_volume();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bodies_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > joints_;
  ::box2d::PbVec2* local_anchor_a_;
  ::box2d::PbVec2* local_anchor_b_;
  ::box2d::PbVec2* local_axis_a_;
  ::box2d::PbVec2* ground_anchor_a_;
  ::box2d::PbVec2* ground_anchor_b_;
  ::box2d::PbVec2* target_;
  ::google::protobuf::int64 tag_;
  ::google::protobuf::int32 body_a_;
  ::google::protobuf::int32 body_b_;
  float ref_angle_;
  bool collideconnected_;
  bool enable_limit_;
  bool enable_motor_;
  float lower_limit_;
  float upper_limit_;
  float motor_speed_;
  float max_motor_torque_;
  float max_motor_force_;
  float length_;
  float frequency_;
  float damping_ratio_;
  float target_volume_;
  float length_a_;
  float length_b_;
  float ratio_;
  float max_length_a_;
  float max_length_b_;
  float max_force_;
  ::google::protobuf::int32 joint1_;
  ::google::protobuf::int32 joint2_;
  float spring_frequency_;
  float spring_damping_ratio_;
  float max_torque_;
  float max_length_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbJointImpl();
};
// -------------------------------------------------------------------

class PbBody : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbBody) */ {
 public:
  PbBody();
  virtual ~PbBody();

  PbBody(const PbBody& from);

  inline PbBody& operator=(const PbBody& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbBody(PbBody&& from) noexcept
    : PbBody() {
    *this = ::std::move(from);
  }

  inline PbBody& operator=(PbBody&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbBody& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbBody* internal_default_instance() {
    return reinterpret_cast<const PbBody*>(
               &_PbBody_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PbBody* other);
  friend void swap(PbBody& a, PbBody& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbBody* New() const PROTOBUF_FINAL { return New(NULL); }

  PbBody* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbBody& from);
  void MergeFrom(const PbBody& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .box2d.PbFixture fixtures = 100;
  int fixtures_size() const;
  void clear_fixtures();
  static const int kFixturesFieldNumber = 100;
  const ::box2d::PbFixture& fixtures(int index) const;
  ::box2d::PbFixture* mutable_fixtures(int index);
  ::box2d::PbFixture* add_fixtures();
  ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >*
      mutable_fixtures();
  const ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >&
      fixtures() const;

  // optional string UUID = 60;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 60;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional .box2d.PbVec2 position = 10;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 10;
  const ::box2d::PbVec2& position() const;
  ::box2d::PbVec2* release_position();
  ::box2d::PbVec2* mutable_position();
  void set_allocated_position(::box2d::PbVec2* position);

  // optional .box2d.PbVec2 linear_velocity = 12;
  bool has_linear_velocity() const;
  void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 12;
  const ::box2d::PbVec2& linear_velocity() const;
  ::box2d::PbVec2* release_linear_velocity();
  ::box2d::PbVec2* mutable_linear_velocity();
  void set_allocated_linear_velocity(::box2d::PbVec2* linear_velocity);

  // optional .box2d.PbVec2 force = 14;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 14;
  const ::box2d::PbVec2& force() const;
  ::box2d::PbVec2* release_force();
  ::box2d::PbVec2* mutable_force();
  void set_allocated_force(::box2d::PbVec2* force);

  // optional int64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::int64 tag() const;
  void set_tag(::google::protobuf::int64 value);

  // required .box2d.PbBodyType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::box2d::PbBodyType type() const;
  void set_type(::box2d::PbBodyType value);

  // optional float angle = 11;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 11;
  float angle() const;
  void set_angle(float value);

  // optional float angular_velocity = 13;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 13;
  float angular_velocity() const;
  void set_angular_velocity(float value);

  // optional float torque = 15;
  bool has_torque() const;
  void clear_torque();
  static const int kTorqueFieldNumber = 15;
  float torque() const;
  void set_torque(float value);

  // optional float mass = 16;
  bool has_mass() const;
  void clear_mass();
  static const int kMassFieldNumber = 16;
  float mass() const;
  void set_mass(float value);

  // optional float I = 17;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 17;
  float i() const;
  void set_i(float value);

  // optional bool fixed_rotation = 57;
  bool has_fixed_rotation() const;
  void clear_fixed_rotation();
  static const int kFixedRotationFieldNumber = 57;
  bool fixed_rotation() const;
  void set_fixed_rotation(bool value);

  // optional float linear_damping = 50;
  bool has_linear_damping() const;
  void clear_linear_damping();
  static const int kLinearDampingFieldNumber = 50;
  float linear_damping() const;
  void set_linear_damping(float value);

  // optional float angular_damping = 51;
  bool has_angular_damping() const;
  void clear_angular_damping();
  static const int kAngularDampingFieldNumber = 51;
  float angular_damping() const;
  void set_angular_damping(float value);

  // optional float gravity_scale = 52;
  bool has_gravity_scale() const;
  void clear_gravity_scale();
  static const int kGravityScaleFieldNumber = 52;
  float gravity_scale() const;
  void set_gravity_scale(float value);

  // optional bool bullet = 53;
  bool has_bullet() const;
  void clear_bullet();
  static const int kBulletFieldNumber = 53;
  bool bullet() const;
  void set_bullet(bool value);

  // optional bool allow_sleep = 54;
  bool has_allow_sleep() const;
  void clear_allow_sleep();
  static const int kAllowSleepFieldNumber = 54;
  bool allow_sleep() const;
  void set_allow_sleep(bool value);

  // optional bool awake = 55;
  bool has_awake() const;
  void clear_awake();
  static const int kAwakeFieldNumber = 55;
  bool awake() const;
  void set_awake(bool value);

  // optional bool active = 56;
  bool has_active() const;
  void clear_active();
  static const int kActiveFieldNumber = 56;
  bool active() const;
  void set_active(bool value);

  // @@protoc_insertion_point(class_scope:box2d.PbBody)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_type();
  void clear_has_type();
  void set_has_position();
  void clear_has_position();
  void set_has_angle();
  void clear_has_angle();
  void set_has_linear_velocity();
  void clear_has_linear_velocity();
  void set_has_angular_velocity();
  void clear_has_angular_velocity();
  void set_has_force();
  void clear_has_force();
  void set_has_torque();
  void clear_has_torque();
  void set_has_mass();
  void clear_has_mass();
  void set_has_i();
  void clear_has_i();
  void set_has_linear_damping();
  void clear_has_linear_damping();
  void set_has_angular_damping();
  void clear_has_angular_damping();
  void set_has_gravity_scale();
  void clear_has_gravity_scale();
  void set_has_bullet();
  void clear_has_bullet();
  void set_has_allow_sleep();
  void clear_has_allow_sleep();
  void set_has_awake();
  void clear_has_awake();
  void set_has_active();
  void clear_has_active();
  void set_has_fixed_rotation();
  void clear_has_fixed_rotation();
  void set_has_uuid();
  void clear_has_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture > fixtures_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::box2d::PbVec2* position_;
  ::box2d::PbVec2* linear_velocity_;
  ::box2d::PbVec2* force_;
  ::google::protobuf::int64 tag_;
  int type_;
  float angle_;
  float angular_velocity_;
  float torque_;
  float mass_;
  float i_;
  bool fixed_rotation_;
  float linear_damping_;
  float angular_damping_;
  float gravity_scale_;
  bool bullet_;
  bool allow_sleep_;
  bool awake_;
  bool active_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbBodyImpl();
};
// -------------------------------------------------------------------

class PbWorld : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:box2d.PbWorld) */ {
 public:
  PbWorld();
  virtual ~PbWorld();

  PbWorld(const PbWorld& from);

  inline PbWorld& operator=(const PbWorld& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PbWorld(PbWorld&& from) noexcept
    : PbWorld() {
    *this = ::std::move(from);
  }

  inline PbWorld& operator=(PbWorld&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbWorld& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PbWorld* internal_default_instance() {
    return reinterpret_cast<const PbWorld*>(
               &_PbWorld_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PbWorld* other);
  friend void swap(PbWorld& a, PbWorld& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PbWorld* New() const PROTOBUF_FINAL { return New(NULL); }

  PbWorld* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbWorld& from);
  void MergeFrom(const PbWorld& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbWorld* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .box2d.PbBody bodies = 20;
  int bodies_size() const;
  void clear_bodies();
  static const int kBodiesFieldNumber = 20;
  const ::box2d::PbBody& bodies(int index) const;
  ::box2d::PbBody* mutable_bodies(int index);
  ::box2d::PbBody* add_bodies();
  ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >*
      mutable_bodies();
  const ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >&
      bodies() const;

  // repeated .box2d.PbJoint joints = 21;
  int joints_size() const;
  void clear_joints();
  static const int kJointsFieldNumber = 21;
  const ::box2d::PbJoint& joints(int index) const;
  ::box2d::PbJoint* mutable_joints(int index);
  ::box2d::PbJoint* add_joints();
  ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >*
      mutable_joints();
  const ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >&
      joints() const;

  // optional .box2d.PbVec2 gravity = 2;
  bool has_gravity() const;
  void clear_gravity();
  static const int kGravityFieldNumber = 2;
  const ::box2d::PbVec2& gravity() const;
  ::box2d::PbVec2* release_gravity();
  ::box2d::PbVec2* mutable_gravity();
  void set_allocated_gravity(::box2d::PbVec2* gravity);

  // optional int64 tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  ::google::protobuf::int64 tag() const;
  void set_tag(::google::protobuf::int64 value);

  // optional bool allow_sleep = 3;
  bool has_allow_sleep() const;
  void clear_allow_sleep();
  static const int kAllowSleepFieldNumber = 3;
  bool allow_sleep() const;
  void set_allow_sleep(bool value);

  // optional bool auto_clear_forces = 4;
  bool has_auto_clear_forces() const;
  void clear_auto_clear_forces();
  static const int kAutoClearForcesFieldNumber = 4;
  bool auto_clear_forces() const;
  void set_auto_clear_forces(bool value);

  // optional bool warm_starting = 5;
  bool has_warm_starting() const;
  void clear_warm_starting();
  static const int kWarmStartingFieldNumber = 5;
  bool warm_starting() const;
  void set_warm_starting(bool value);

  // optional bool continuous_physics = 6;
  bool has_continuous_physics() const;
  void clear_continuous_physics();
  static const int kContinuousPhysicsFieldNumber = 6;
  bool continuous_physics() const;
  void set_continuous_physics(bool value);

  // optional bool sub_stepping = 7;
  bool has_sub_stepping() const;
  void clear_sub_stepping();
  static const int kSubSteppingFieldNumber = 7;
  bool sub_stepping() const;
  void set_sub_stepping(bool value);

  // @@protoc_insertion_point(class_scope:box2d.PbWorld)
 private:
  void set_has_tag();
  void clear_has_tag();
  void set_has_gravity();
  void clear_has_gravity();
  void set_has_allow_sleep();
  void clear_has_allow_sleep();
  void set_has_auto_clear_forces();
  void clear_has_auto_clear_forces();
  void set_has_warm_starting();
  void clear_has_warm_starting();
  void set_has_continuous_physics();
  void clear_has_continuous_physics();
  void set_has_sub_stepping();
  void clear_has_sub_stepping();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbBody > bodies_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint > joints_;
  ::box2d::PbVec2* gravity_;
  ::google::protobuf::int64 tag_;
  bool allow_sleep_;
  bool auto_clear_forces_;
  bool warm_starting_;
  bool continuous_physics_;
  bool sub_stepping_;
  friend struct ::protobuf_box2d_2eproto::TableStruct;
  friend void ::protobuf_box2d_2eproto::InitDefaultsPbWorldImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PbVec2

// required float x = 1;
inline bool PbVec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbVec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbVec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbVec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PbVec2::x() const {
  // @@protoc_insertion_point(field_get:box2d.PbVec2.x)
  return x_;
}
inline void PbVec2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbVec2.x)
}

// required float y = 2;
inline bool PbVec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbVec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbVec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbVec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PbVec2::y() const {
  // @@protoc_insertion_point(field_get:box2d.PbVec2.y)
  return y_;
}
inline void PbVec2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbVec2.y)
}

// -------------------------------------------------------------------

// PbFilter

// optional int32 category_bits = 1;
inline bool PbFilter::has_category_bits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbFilter::set_has_category_bits() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbFilter::clear_has_category_bits() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbFilter::clear_category_bits() {
  category_bits_ = 0;
  clear_has_category_bits();
}
inline ::google::protobuf::int32 PbFilter::category_bits() const {
  // @@protoc_insertion_point(field_get:box2d.PbFilter.category_bits)
  return category_bits_;
}
inline void PbFilter::set_category_bits(::google::protobuf::int32 value) {
  set_has_category_bits();
  category_bits_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFilter.category_bits)
}

// optional int32 mask_bits = 2;
inline bool PbFilter::has_mask_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbFilter::set_has_mask_bits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbFilter::clear_has_mask_bits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbFilter::clear_mask_bits() {
  mask_bits_ = 0;
  clear_has_mask_bits();
}
inline ::google::protobuf::int32 PbFilter::mask_bits() const {
  // @@protoc_insertion_point(field_get:box2d.PbFilter.mask_bits)
  return mask_bits_;
}
inline void PbFilter::set_mask_bits(::google::protobuf::int32 value) {
  set_has_mask_bits();
  mask_bits_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFilter.mask_bits)
}

// optional int32 group_index = 3;
inline bool PbFilter::has_group_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbFilter::set_has_group_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbFilter::clear_has_group_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbFilter::clear_group_index() {
  group_index_ = 0;
  clear_has_group_index();
}
inline ::google::protobuf::int32 PbFilter::group_index() const {
  // @@protoc_insertion_point(field_get:box2d.PbFilter.group_index)
  return group_index_;
}
inline void PbFilter::set_group_index(::google::protobuf::int32 value) {
  set_has_group_index();
  group_index_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFilter.group_index)
}

// -------------------------------------------------------------------

// PbShape

// optional int64 tag = 1;
inline bool PbShape::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbShape::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbShape::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbShape::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbShape::tag() const {
  // @@protoc_insertion_point(field_get:box2d.PbShape.tag)
  return tag_;
}
inline void PbShape::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbShape.tag)
}

// required .box2d.PbShapeType type = 2;
inline bool PbShape::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbShape::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbShape::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbShape::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::box2d::PbShapeType PbShape::type() const {
  // @@protoc_insertion_point(field_get:box2d.PbShape.type)
  return static_cast< ::box2d::PbShapeType >(type_);
}
inline void PbShape::set_type(::box2d::PbShapeType value) {
  assert(::box2d::PbShapeType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbShape.type)
}

// optional .box2d.PbVec2 center = 10;
inline bool PbShape::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbShape::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbShape::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbShape::clear_center() {
  if (center_ != NULL) center_->Clear();
  clear_has_center();
}
inline const ::box2d::PbVec2& PbShape::center() const {
  const ::box2d::PbVec2* p = center_;
  // @@protoc_insertion_point(field_get:box2d.PbShape.center)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbShape::release_center() {
  // @@protoc_insertion_point(field_release:box2d.PbShape.center)
  clear_has_center();
  ::box2d::PbVec2* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbShape::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    center_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbShape.center)
  return center_;
}
inline void PbShape::set_allocated_center(::box2d::PbVec2* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbShape.center)
}

// optional float radius = 11;
inline bool PbShape::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbShape::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbShape::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbShape::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float PbShape::radius() const {
  // @@protoc_insertion_point(field_get:box2d.PbShape.radius)
  return radius_;
}
inline void PbShape::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbShape.radius)
}

// repeated .box2d.PbVec2 points = 20;
inline int PbShape::points_size() const {
  return points_.size();
}
inline void PbShape::clear_points() {
  points_.Clear();
}
inline const ::box2d::PbVec2& PbShape::points(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbShape.points)
  return points_.Get(index);
}
inline ::box2d::PbVec2* PbShape::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:box2d.PbShape.points)
  return points_.Mutable(index);
}
inline ::box2d::PbVec2* PbShape::add_points() {
  // @@protoc_insertion_point(field_add:box2d.PbShape.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
PbShape::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbShape.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
PbShape::points() const {
  // @@protoc_insertion_point(field_list:box2d.PbShape.points)
  return points_;
}

// repeated .box2d.PbVec2 normals = 21;
inline int PbShape::normals_size() const {
  return normals_.size();
}
inline void PbShape::clear_normals() {
  normals_.Clear();
}
inline const ::box2d::PbVec2& PbShape::normals(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbShape.normals)
  return normals_.Get(index);
}
inline ::box2d::PbVec2* PbShape::mutable_normals(int index) {
  // @@protoc_insertion_point(field_mutable:box2d.PbShape.normals)
  return normals_.Mutable(index);
}
inline ::box2d::PbVec2* PbShape::add_normals() {
  // @@protoc_insertion_point(field_add:box2d.PbShape.normals)
  return normals_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
PbShape::mutable_normals() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbShape.normals)
  return &normals_;
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
PbShape::normals() const {
  // @@protoc_insertion_point(field_list:box2d.PbShape.normals)
  return normals_;
}

// optional .box2d.PbVec2 centroid = 22;
inline bool PbShape::has_centroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbShape::set_has_centroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbShape::clear_has_centroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbShape::clear_centroid() {
  if (centroid_ != NULL) centroid_->Clear();
  clear_has_centroid();
}
inline const ::box2d::PbVec2& PbShape::centroid() const {
  const ::box2d::PbVec2* p = centroid_;
  // @@protoc_insertion_point(field_get:box2d.PbShape.centroid)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbShape::release_centroid() {
  // @@protoc_insertion_point(field_release:box2d.PbShape.centroid)
  clear_has_centroid();
  ::box2d::PbVec2* temp = centroid_;
  centroid_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbShape::mutable_centroid() {
  set_has_centroid();
  if (centroid_ == NULL) {
    centroid_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbShape.centroid)
  return centroid_;
}
inline void PbShape::set_allocated_centroid(::box2d::PbVec2* centroid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete centroid_;
  }
  if (centroid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      centroid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, centroid, submessage_arena);
    }
    set_has_centroid();
  } else {
    clear_has_centroid();
  }
  centroid_ = centroid;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbShape.centroid)
}

// -------------------------------------------------------------------

// PbFixture

// optional int64 tag = 1;
inline bool PbFixture::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbFixture::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbFixture::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbFixture::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbFixture::tag() const {
  // @@protoc_insertion_point(field_get:box2d.PbFixture.tag)
  return tag_;
}
inline void PbFixture::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFixture.tag)
}

// optional float restitution = 2;
inline bool PbFixture::has_restitution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbFixture::set_has_restitution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbFixture::clear_has_restitution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbFixture::clear_restitution() {
  restitution_ = 0;
  clear_has_restitution();
}
inline float PbFixture::restitution() const {
  // @@protoc_insertion_point(field_get:box2d.PbFixture.restitution)
  return restitution_;
}
inline void PbFixture::set_restitution(float value) {
  set_has_restitution();
  restitution_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFixture.restitution)
}

// optional float friction = 3;
inline bool PbFixture::has_friction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbFixture::set_has_friction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbFixture::clear_has_friction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbFixture::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
inline float PbFixture::friction() const {
  // @@protoc_insertion_point(field_get:box2d.PbFixture.friction)
  return friction_;
}
inline void PbFixture::set_friction(float value) {
  set_has_friction();
  friction_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFixture.friction)
}

// optional float density = 4;
inline bool PbFixture::has_density() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbFixture::set_has_density() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbFixture::clear_has_density() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbFixture::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float PbFixture::density() const {
  // @@protoc_insertion_point(field_get:box2d.PbFixture.density)
  return density_;
}
inline void PbFixture::set_density(float value) {
  set_has_density();
  density_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFixture.density)
}

// optional bool sensor = 5;
inline bool PbFixture::has_sensor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbFixture::set_has_sensor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbFixture::clear_has_sensor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbFixture::clear_sensor() {
  sensor_ = false;
  clear_has_sensor();
}
inline bool PbFixture::sensor() const {
  // @@protoc_insertion_point(field_get:box2d.PbFixture.sensor)
  return sensor_;
}
inline void PbFixture::set_sensor(bool value) {
  set_has_sensor();
  sensor_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbFixture.sensor)
}

// optional .box2d.PbFilter filter = 10;
inline bool PbFixture::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbFixture::set_has_filter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbFixture::clear_has_filter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbFixture::clear_filter() {
  if (filter_ != NULL) filter_->Clear();
  clear_has_filter();
}
inline const ::box2d::PbFilter& PbFixture::filter() const {
  const ::box2d::PbFilter* p = filter_;
  // @@protoc_insertion_point(field_get:box2d.PbFixture.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbFilter*>(
      &::box2d::_PbFilter_default_instance_);
}
inline ::box2d::PbFilter* PbFixture::release_filter() {
  // @@protoc_insertion_point(field_release:box2d.PbFixture.filter)
  clear_has_filter();
  ::box2d::PbFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::box2d::PbFilter* PbFixture::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) {
    filter_ = new ::box2d::PbFilter;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbFixture.filter)
  return filter_;
}
inline void PbFixture::set_allocated_filter(::box2d::PbFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    set_has_filter();
  } else {
    clear_has_filter();
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbFixture.filter)
}

// optional .box2d.PbShape shape = 11;
inline bool PbFixture::has_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbFixture::set_has_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbFixture::clear_has_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbFixture::clear_shape() {
  if (shape_ != NULL) shape_->Clear();
  clear_has_shape();
}
inline const ::box2d::PbShape& PbFixture::shape() const {
  const ::box2d::PbShape* p = shape_;
  // @@protoc_insertion_point(field_get:box2d.PbFixture.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbShape*>(
      &::box2d::_PbShape_default_instance_);
}
inline ::box2d::PbShape* PbFixture::release_shape() {
  // @@protoc_insertion_point(field_release:box2d.PbFixture.shape)
  clear_has_shape();
  ::box2d::PbShape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::box2d::PbShape* PbFixture::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) {
    shape_ = new ::box2d::PbShape;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbFixture.shape)
  return shape_;
}
inline void PbFixture::set_allocated_shape(::box2d::PbShape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shape_;
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbFixture.shape)
}

// -------------------------------------------------------------------

// PbJoint

// optional int64 tag = 1;
inline bool PbJoint::has_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbJoint::set_has_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbJoint::clear_has_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbJoint::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbJoint::tag() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.tag)
  return tag_;
}
inline void PbJoint::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.tag)
}

// required .box2d.PbJointType type = 2;
inline bool PbJoint::has_type() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PbJoint::set_has_type() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PbJoint::clear_has_type() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PbJoint::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::box2d::PbJointType PbJoint::type() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.type)
  return static_cast< ::box2d::PbJointType >(type_);
}
inline void PbJoint::set_type(::box2d::PbJointType value) {
  assert(::box2d::PbJointType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.type)
}

// optional int32 body_a = 3;
inline bool PbJoint::has_body_a() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PbJoint::set_has_body_a() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PbJoint::clear_has_body_a() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PbJoint::clear_body_a() {
  body_a_ = 0;
  clear_has_body_a();
}
inline ::google::protobuf::int32 PbJoint::body_a() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.body_a)
  return body_a_;
}
inline void PbJoint::set_body_a(::google::protobuf::int32 value) {
  set_has_body_a();
  body_a_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.body_a)
}

// optional int32 body_b = 4;
inline bool PbJoint::has_body_b() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PbJoint::set_has_body_b() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PbJoint::clear_has_body_b() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PbJoint::clear_body_b() {
  body_b_ = 0;
  clear_has_body_b();
}
inline ::google::protobuf::int32 PbJoint::body_b() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.body_b)
  return body_b_;
}
inline void PbJoint::set_body_b(::google::protobuf::int32 value) {
  set_has_body_b();
  body_b_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.body_b)
}

// optional bool collideConnected = 5;
inline bool PbJoint::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PbJoint::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PbJoint::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PbJoint::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool PbJoint::collideconnected() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.collideConnected)
  return collideconnected_;
}
inline void PbJoint::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.collideConnected)
}

// optional .box2d.PbVec2 local_anchor_a = 6;
inline bool PbJoint::has_local_anchor_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbJoint::set_has_local_anchor_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbJoint::clear_has_local_anchor_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbJoint::clear_local_anchor_a() {
  if (local_anchor_a_ != NULL) local_anchor_a_->Clear();
  clear_has_local_anchor_a();
}
inline const ::box2d::PbVec2& PbJoint::local_anchor_a() const {
  const ::box2d::PbVec2* p = local_anchor_a_;
  // @@protoc_insertion_point(field_get:box2d.PbJoint.local_anchor_a)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbJoint::release_local_anchor_a() {
  // @@protoc_insertion_point(field_release:box2d.PbJoint.local_anchor_a)
  clear_has_local_anchor_a();
  ::box2d::PbVec2* temp = local_anchor_a_;
  local_anchor_a_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbJoint::mutable_local_anchor_a() {
  set_has_local_anchor_a();
  if (local_anchor_a_ == NULL) {
    local_anchor_a_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbJoint.local_anchor_a)
  return local_anchor_a_;
}
inline void PbJoint::set_allocated_local_anchor_a(::box2d::PbVec2* local_anchor_a) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete local_anchor_a_;
  }
  if (local_anchor_a) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_anchor_a = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_anchor_a, submessage_arena);
    }
    set_has_local_anchor_a();
  } else {
    clear_has_local_anchor_a();
  }
  local_anchor_a_ = local_anchor_a;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbJoint.local_anchor_a)
}

// optional .box2d.PbVec2 local_anchor_b = 7;
inline bool PbJoint::has_local_anchor_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbJoint::set_has_local_anchor_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbJoint::clear_has_local_anchor_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbJoint::clear_local_anchor_b() {
  if (local_anchor_b_ != NULL) local_anchor_b_->Clear();
  clear_has_local_anchor_b();
}
inline const ::box2d::PbVec2& PbJoint::local_anchor_b() const {
  const ::box2d::PbVec2* p = local_anchor_b_;
  // @@protoc_insertion_point(field_get:box2d.PbJoint.local_anchor_b)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbJoint::release_local_anchor_b() {
  // @@protoc_insertion_point(field_release:box2d.PbJoint.local_anchor_b)
  clear_has_local_anchor_b();
  ::box2d::PbVec2* temp = local_anchor_b_;
  local_anchor_b_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbJoint::mutable_local_anchor_b() {
  set_has_local_anchor_b();
  if (local_anchor_b_ == NULL) {
    local_anchor_b_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbJoint.local_anchor_b)
  return local_anchor_b_;
}
inline void PbJoint::set_allocated_local_anchor_b(::box2d::PbVec2* local_anchor_b) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete local_anchor_b_;
  }
  if (local_anchor_b) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_anchor_b = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_anchor_b, submessage_arena);
    }
    set_has_local_anchor_b();
  } else {
    clear_has_local_anchor_b();
  }
  local_anchor_b_ = local_anchor_b;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbJoint.local_anchor_b)
}

// optional float ref_angle = 10;
inline bool PbJoint::has_ref_angle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PbJoint::set_has_ref_angle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PbJoint::clear_has_ref_angle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PbJoint::clear_ref_angle() {
  ref_angle_ = 0;
  clear_has_ref_angle();
}
inline float PbJoint::ref_angle() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.ref_angle)
  return ref_angle_;
}
inline void PbJoint::set_ref_angle(float value) {
  set_has_ref_angle();
  ref_angle_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.ref_angle)
}

// optional bool enable_limit = 12;
inline bool PbJoint::has_enable_limit() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PbJoint::set_has_enable_limit() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PbJoint::clear_has_enable_limit() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PbJoint::clear_enable_limit() {
  enable_limit_ = false;
  clear_has_enable_limit();
}
inline bool PbJoint::enable_limit() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.enable_limit)
  return enable_limit_;
}
inline void PbJoint::set_enable_limit(bool value) {
  set_has_enable_limit();
  enable_limit_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.enable_limit)
}

// optional float lower_limit = 13;
inline bool PbJoint::has_lower_limit() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PbJoint::set_has_lower_limit() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PbJoint::clear_has_lower_limit() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PbJoint::clear_lower_limit() {
  lower_limit_ = 0;
  clear_has_lower_limit();
}
inline float PbJoint::lower_limit() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.lower_limit)
  return lower_limit_;
}
inline void PbJoint::set_lower_limit(float value) {
  set_has_lower_limit();
  lower_limit_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.lower_limit)
}

// optional float upper_limit = 14;
inline bool PbJoint::has_upper_limit() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PbJoint::set_has_upper_limit() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PbJoint::clear_has_upper_limit() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PbJoint::clear_upper_limit() {
  upper_limit_ = 0;
  clear_has_upper_limit();
}
inline float PbJoint::upper_limit() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.upper_limit)
  return upper_limit_;
}
inline void PbJoint::set_upper_limit(float value) {
  set_has_upper_limit();
  upper_limit_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.upper_limit)
}

// optional bool enable_motor = 15;
inline bool PbJoint::has_enable_motor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PbJoint::set_has_enable_motor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PbJoint::clear_has_enable_motor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PbJoint::clear_enable_motor() {
  enable_motor_ = false;
  clear_has_enable_motor();
}
inline bool PbJoint::enable_motor() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.enable_motor)
  return enable_motor_;
}
inline void PbJoint::set_enable_motor(bool value) {
  set_has_enable_motor();
  enable_motor_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.enable_motor)
}

// optional float motor_speed = 16;
inline bool PbJoint::has_motor_speed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PbJoint::set_has_motor_speed() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PbJoint::clear_has_motor_speed() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PbJoint::clear_motor_speed() {
  motor_speed_ = 0;
  clear_has_motor_speed();
}
inline float PbJoint::motor_speed() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.motor_speed)
  return motor_speed_;
}
inline void PbJoint::set_motor_speed(float value) {
  set_has_motor_speed();
  motor_speed_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.motor_speed)
}

// optional float max_motor_torque = 17;
inline bool PbJoint::has_max_motor_torque() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PbJoint::set_has_max_motor_torque() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PbJoint::clear_has_max_motor_torque() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PbJoint::clear_max_motor_torque() {
  max_motor_torque_ = 0;
  clear_has_max_motor_torque();
}
inline float PbJoint::max_motor_torque() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_motor_torque)
  return max_motor_torque_;
}
inline void PbJoint::set_max_motor_torque(float value) {
  set_has_max_motor_torque();
  max_motor_torque_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_motor_torque)
}

// optional .box2d.PbVec2 local_axis_a = 20;
inline bool PbJoint::has_local_axis_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbJoint::set_has_local_axis_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbJoint::clear_has_local_axis_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbJoint::clear_local_axis_a() {
  if (local_axis_a_ != NULL) local_axis_a_->Clear();
  clear_has_local_axis_a();
}
inline const ::box2d::PbVec2& PbJoint::local_axis_a() const {
  const ::box2d::PbVec2* p = local_axis_a_;
  // @@protoc_insertion_point(field_get:box2d.PbJoint.local_axis_a)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbJoint::release_local_axis_a() {
  // @@protoc_insertion_point(field_release:box2d.PbJoint.local_axis_a)
  clear_has_local_axis_a();
  ::box2d::PbVec2* temp = local_axis_a_;
  local_axis_a_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbJoint::mutable_local_axis_a() {
  set_has_local_axis_a();
  if (local_axis_a_ == NULL) {
    local_axis_a_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbJoint.local_axis_a)
  return local_axis_a_;
}
inline void PbJoint::set_allocated_local_axis_a(::box2d::PbVec2* local_axis_a) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete local_axis_a_;
  }
  if (local_axis_a) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_axis_a = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_axis_a, submessage_arena);
    }
    set_has_local_axis_a();
  } else {
    clear_has_local_axis_a();
  }
  local_axis_a_ = local_axis_a;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbJoint.local_axis_a)
}

// optional float max_motor_force = 21;
inline bool PbJoint::has_max_motor_force() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PbJoint::set_has_max_motor_force() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PbJoint::clear_has_max_motor_force() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PbJoint::clear_max_motor_force() {
  max_motor_force_ = 0;
  clear_has_max_motor_force();
}
inline float PbJoint::max_motor_force() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_motor_force)
  return max_motor_force_;
}
inline void PbJoint::set_max_motor_force(float value) {
  set_has_max_motor_force();
  max_motor_force_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_motor_force)
}

// optional float length = 30;
inline bool PbJoint::has_length() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PbJoint::set_has_length() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PbJoint::clear_has_length() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PbJoint::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float PbJoint::length() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.length)
  return length_;
}
inline void PbJoint::set_length(float value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.length)
}

// optional float frequency = 31;
inline bool PbJoint::has_frequency() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PbJoint::set_has_frequency() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PbJoint::clear_has_frequency() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PbJoint::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline float PbJoint::frequency() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.frequency)
  return frequency_;
}
inline void PbJoint::set_frequency(float value) {
  set_has_frequency();
  frequency_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.frequency)
}

// optional float damping_ratio = 32;
inline bool PbJoint::has_damping_ratio() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PbJoint::set_has_damping_ratio() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PbJoint::clear_has_damping_ratio() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PbJoint::clear_damping_ratio() {
  damping_ratio_ = 0;
  clear_has_damping_ratio();
}
inline float PbJoint::damping_ratio() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.damping_ratio)
  return damping_ratio_;
}
inline void PbJoint::set_damping_ratio(float value) {
  set_has_damping_ratio();
  damping_ratio_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.damping_ratio)
}

// optional .box2d.PbVec2 ground_anchor_a = 40;
inline bool PbJoint::has_ground_anchor_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbJoint::set_has_ground_anchor_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbJoint::clear_has_ground_anchor_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbJoint::clear_ground_anchor_a() {
  if (ground_anchor_a_ != NULL) ground_anchor_a_->Clear();
  clear_has_ground_anchor_a();
}
inline const ::box2d::PbVec2& PbJoint::ground_anchor_a() const {
  const ::box2d::PbVec2* p = ground_anchor_a_;
  // @@protoc_insertion_point(field_get:box2d.PbJoint.ground_anchor_a)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbJoint::release_ground_anchor_a() {
  // @@protoc_insertion_point(field_release:box2d.PbJoint.ground_anchor_a)
  clear_has_ground_anchor_a();
  ::box2d::PbVec2* temp = ground_anchor_a_;
  ground_anchor_a_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbJoint::mutable_ground_anchor_a() {
  set_has_ground_anchor_a();
  if (ground_anchor_a_ == NULL) {
    ground_anchor_a_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbJoint.ground_anchor_a)
  return ground_anchor_a_;
}
inline void PbJoint::set_allocated_ground_anchor_a(::box2d::PbVec2* ground_anchor_a) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ground_anchor_a_;
  }
  if (ground_anchor_a) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ground_anchor_a = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ground_anchor_a, submessage_arena);
    }
    set_has_ground_anchor_a();
  } else {
    clear_has_ground_anchor_a();
  }
  ground_anchor_a_ = ground_anchor_a;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbJoint.ground_anchor_a)
}

// optional .box2d.PbVec2 ground_anchor_b = 41;
inline bool PbJoint::has_ground_anchor_b() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbJoint::set_has_ground_anchor_b() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbJoint::clear_has_ground_anchor_b() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbJoint::clear_ground_anchor_b() {
  if (ground_anchor_b_ != NULL) ground_anchor_b_->Clear();
  clear_has_ground_anchor_b();
}
inline const ::box2d::PbVec2& PbJoint::ground_anchor_b() const {
  const ::box2d::PbVec2* p = ground_anchor_b_;
  // @@protoc_insertion_point(field_get:box2d.PbJoint.ground_anchor_b)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbJoint::release_ground_anchor_b() {
  // @@protoc_insertion_point(field_release:box2d.PbJoint.ground_anchor_b)
  clear_has_ground_anchor_b();
  ::box2d::PbVec2* temp = ground_anchor_b_;
  ground_anchor_b_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbJoint::mutable_ground_anchor_b() {
  set_has_ground_anchor_b();
  if (ground_anchor_b_ == NULL) {
    ground_anchor_b_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbJoint.ground_anchor_b)
  return ground_anchor_b_;
}
inline void PbJoint::set_allocated_ground_anchor_b(::box2d::PbVec2* ground_anchor_b) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ground_anchor_b_;
  }
  if (ground_anchor_b) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ground_anchor_b = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ground_anchor_b, submessage_arena);
    }
    set_has_ground_anchor_b();
  } else {
    clear_has_ground_anchor_b();
  }
  ground_anchor_b_ = ground_anchor_b;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbJoint.ground_anchor_b)
}

// optional float length_a = 42;
inline bool PbJoint::has_length_a() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PbJoint::set_has_length_a() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PbJoint::clear_has_length_a() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PbJoint::clear_length_a() {
  length_a_ = 0;
  clear_has_length_a();
}
inline float PbJoint::length_a() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.length_a)
  return length_a_;
}
inline void PbJoint::set_length_a(float value) {
  set_has_length_a();
  length_a_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.length_a)
}

// optional float length_b = 43;
inline bool PbJoint::has_length_b() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PbJoint::set_has_length_b() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PbJoint::clear_has_length_b() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PbJoint::clear_length_b() {
  length_b_ = 0;
  clear_has_length_b();
}
inline float PbJoint::length_b() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.length_b)
  return length_b_;
}
inline void PbJoint::set_length_b(float value) {
  set_has_length_b();
  length_b_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.length_b)
}

// optional float ratio = 44;
inline bool PbJoint::has_ratio() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PbJoint::set_has_ratio() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PbJoint::clear_has_ratio() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PbJoint::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline float PbJoint::ratio() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.ratio)
  return ratio_;
}
inline void PbJoint::set_ratio(float value) {
  set_has_ratio();
  ratio_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.ratio)
}

// optional float max_length_a = 45;
inline bool PbJoint::has_max_length_a() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PbJoint::set_has_max_length_a() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PbJoint::clear_has_max_length_a() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PbJoint::clear_max_length_a() {
  max_length_a_ = 0;
  clear_has_max_length_a();
}
inline float PbJoint::max_length_a() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_length_a)
  return max_length_a_;
}
inline void PbJoint::set_max_length_a(float value) {
  set_has_max_length_a();
  max_length_a_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_length_a)
}

// optional float max_length_b = 46;
inline bool PbJoint::has_max_length_b() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PbJoint::set_has_max_length_b() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PbJoint::clear_has_max_length_b() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PbJoint::clear_max_length_b() {
  max_length_b_ = 0;
  clear_has_max_length_b();
}
inline float PbJoint::max_length_b() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_length_b)
  return max_length_b_;
}
inline void PbJoint::set_max_length_b(float value) {
  set_has_max_length_b();
  max_length_b_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_length_b)
}

// optional .box2d.PbVec2 target = 50;
inline bool PbJoint::has_target() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbJoint::set_has_target() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbJoint::clear_has_target() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbJoint::clear_target() {
  if (target_ != NULL) target_->Clear();
  clear_has_target();
}
inline const ::box2d::PbVec2& PbJoint::target() const {
  const ::box2d::PbVec2* p = target_;
  // @@protoc_insertion_point(field_get:box2d.PbJoint.target)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbJoint::release_target() {
  // @@protoc_insertion_point(field_release:box2d.PbJoint.target)
  clear_has_target();
  ::box2d::PbVec2* temp = target_;
  target_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbJoint::mutable_target() {
  set_has_target();
  if (target_ == NULL) {
    target_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbJoint.target)
  return target_;
}
inline void PbJoint::set_allocated_target(::box2d::PbVec2* target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete target_;
  }
  if (target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    set_has_target();
  } else {
    clear_has_target();
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbJoint.target)
}

// optional float max_force = 51;
inline bool PbJoint::has_max_force() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PbJoint::set_has_max_force() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PbJoint::clear_has_max_force() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PbJoint::clear_max_force() {
  max_force_ = 0;
  clear_has_max_force();
}
inline float PbJoint::max_force() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_force)
  return max_force_;
}
inline void PbJoint::set_max_force(float value) {
  set_has_max_force();
  max_force_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_force)
}

// optional int32 joint1 = 61;
inline bool PbJoint::has_joint1() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PbJoint::set_has_joint1() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PbJoint::clear_has_joint1() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PbJoint::clear_joint1() {
  joint1_ = 0;
  clear_has_joint1();
}
inline ::google::protobuf::int32 PbJoint::joint1() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.joint1)
  return joint1_;
}
inline void PbJoint::set_joint1(::google::protobuf::int32 value) {
  set_has_joint1();
  joint1_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.joint1)
}

// optional int32 joint2 = 62;
inline bool PbJoint::has_joint2() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PbJoint::set_has_joint2() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PbJoint::clear_has_joint2() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PbJoint::clear_joint2() {
  joint2_ = 0;
  clear_has_joint2();
}
inline ::google::protobuf::int32 PbJoint::joint2() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.joint2)
  return joint2_;
}
inline void PbJoint::set_joint2(::google::protobuf::int32 value) {
  set_has_joint2();
  joint2_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.joint2)
}

// optional float spring_frequency = 70;
inline bool PbJoint::has_spring_frequency() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PbJoint::set_has_spring_frequency() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PbJoint::clear_has_spring_frequency() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PbJoint::clear_spring_frequency() {
  spring_frequency_ = 0;
  clear_has_spring_frequency();
}
inline float PbJoint::spring_frequency() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.spring_frequency)
  return spring_frequency_;
}
inline void PbJoint::set_spring_frequency(float value) {
  set_has_spring_frequency();
  spring_frequency_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.spring_frequency)
}

// optional float spring_damping_ratio = 71;
inline bool PbJoint::has_spring_damping_ratio() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PbJoint::set_has_spring_damping_ratio() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PbJoint::clear_has_spring_damping_ratio() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PbJoint::clear_spring_damping_ratio() {
  spring_damping_ratio_ = 0;
  clear_has_spring_damping_ratio();
}
inline float PbJoint::spring_damping_ratio() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.spring_damping_ratio)
  return spring_damping_ratio_;
}
inline void PbJoint::set_spring_damping_ratio(float value) {
  set_has_spring_damping_ratio();
  spring_damping_ratio_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.spring_damping_ratio)
}

// optional float max_torque = 90;
inline bool PbJoint::has_max_torque() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PbJoint::set_has_max_torque() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PbJoint::clear_has_max_torque() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PbJoint::clear_max_torque() {
  max_torque_ = 0;
  clear_has_max_torque();
}
inline float PbJoint::max_torque() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_torque)
  return max_torque_;
}
inline void PbJoint::set_max_torque(float value) {
  set_has_max_torque();
  max_torque_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_torque)
}

// optional float max_length = 100;
inline bool PbJoint::has_max_length() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PbJoint::set_has_max_length() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PbJoint::clear_has_max_length() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PbJoint::clear_max_length() {
  max_length_ = 0;
  clear_has_max_length();
}
inline float PbJoint::max_length() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.max_length)
  return max_length_;
}
inline void PbJoint::set_max_length(float value) {
  set_has_max_length();
  max_length_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.max_length)
}

// repeated int32 bodies = 110;
inline int PbJoint::bodies_size() const {
  return bodies_.size();
}
inline void PbJoint::clear_bodies() {
  bodies_.Clear();
}
inline ::google::protobuf::int32 PbJoint::bodies(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.bodies)
  return bodies_.Get(index);
}
inline void PbJoint::set_bodies(int index, ::google::protobuf::int32 value) {
  bodies_.Set(index, value);
  // @@protoc_insertion_point(field_set:box2d.PbJoint.bodies)
}
inline void PbJoint::add_bodies(::google::protobuf::int32 value) {
  bodies_.Add(value);
  // @@protoc_insertion_point(field_add:box2d.PbJoint.bodies)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PbJoint::bodies() const {
  // @@protoc_insertion_point(field_list:box2d.PbJoint.bodies)
  return bodies_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PbJoint::mutable_bodies() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbJoint.bodies)
  return &bodies_;
}

// repeated int32 joints = 111;
inline int PbJoint::joints_size() const {
  return joints_.size();
}
inline void PbJoint::clear_joints() {
  joints_.Clear();
}
inline ::google::protobuf::int32 PbJoint::joints(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.joints)
  return joints_.Get(index);
}
inline void PbJoint::set_joints(int index, ::google::protobuf::int32 value) {
  joints_.Set(index, value);
  // @@protoc_insertion_point(field_set:box2d.PbJoint.joints)
}
inline void PbJoint::add_joints(::google::protobuf::int32 value) {
  joints_.Add(value);
  // @@protoc_insertion_point(field_add:box2d.PbJoint.joints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PbJoint::joints() const {
  // @@protoc_insertion_point(field_list:box2d.PbJoint.joints)
  return joints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PbJoint::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbJoint.joints)
  return &joints_;
}

// optional float target_volume = 112;
inline bool PbJoint::has_target_volume() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PbJoint::set_has_target_volume() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PbJoint::clear_has_target_volume() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PbJoint::clear_target_volume() {
  target_volume_ = 0;
  clear_has_target_volume();
}
inline float PbJoint::target_volume() const {
  // @@protoc_insertion_point(field_get:box2d.PbJoint.target_volume)
  return target_volume_;
}
inline void PbJoint::set_target_volume(float value) {
  set_has_target_volume();
  target_volume_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbJoint.target_volume)
}

// -------------------------------------------------------------------

// PbBody

// optional int64 tag = 1;
inline bool PbBody::has_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbBody::set_has_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbBody::clear_has_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbBody::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbBody::tag() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.tag)
  return tag_;
}
inline void PbBody::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.tag)
}

// required .box2d.PbBodyType type = 2;
inline bool PbBody::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbBody::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbBody::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbBody::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::box2d::PbBodyType PbBody::type() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.type)
  return static_cast< ::box2d::PbBodyType >(type_);
}
inline void PbBody::set_type(::box2d::PbBodyType value) {
  assert(::box2d::PbBodyType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.type)
}

// optional .box2d.PbVec2 position = 10;
inline bool PbBody::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbBody::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbBody::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbBody::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::box2d::PbVec2& PbBody::position() const {
  const ::box2d::PbVec2* p = position_;
  // @@protoc_insertion_point(field_get:box2d.PbBody.position)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbBody::release_position() {
  // @@protoc_insertion_point(field_release:box2d.PbBody.position)
  clear_has_position();
  ::box2d::PbVec2* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbBody::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbBody.position)
  return position_;
}
inline void PbBody::set_allocated_position(::box2d::PbVec2* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbBody.position)
}

// optional float angle = 11;
inline bool PbBody::has_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbBody::set_has_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbBody::clear_has_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbBody::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float PbBody::angle() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.angle)
  return angle_;
}
inline void PbBody::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.angle)
}

// optional .box2d.PbVec2 linear_velocity = 12;
inline bool PbBody::has_linear_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbBody::set_has_linear_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbBody::clear_has_linear_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbBody::clear_linear_velocity() {
  if (linear_velocity_ != NULL) linear_velocity_->Clear();
  clear_has_linear_velocity();
}
inline const ::box2d::PbVec2& PbBody::linear_velocity() const {
  const ::box2d::PbVec2* p = linear_velocity_;
  // @@protoc_insertion_point(field_get:box2d.PbBody.linear_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbBody::release_linear_velocity() {
  // @@protoc_insertion_point(field_release:box2d.PbBody.linear_velocity)
  clear_has_linear_velocity();
  ::box2d::PbVec2* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbBody::mutable_linear_velocity() {
  set_has_linear_velocity();
  if (linear_velocity_ == NULL) {
    linear_velocity_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbBody.linear_velocity)
  return linear_velocity_;
}
inline void PbBody::set_allocated_linear_velocity(::box2d::PbVec2* linear_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_velocity_;
  }
  if (linear_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    set_has_linear_velocity();
  } else {
    clear_has_linear_velocity();
  }
  linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbBody.linear_velocity)
}

// optional float angular_velocity = 13;
inline bool PbBody::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PbBody::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PbBody::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PbBody::clear_angular_velocity() {
  angular_velocity_ = 0;
  clear_has_angular_velocity();
}
inline float PbBody::angular_velocity() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.angular_velocity)
  return angular_velocity_;
}
inline void PbBody::set_angular_velocity(float value) {
  set_has_angular_velocity();
  angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.angular_velocity)
}

// optional .box2d.PbVec2 force = 14;
inline bool PbBody::has_force() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbBody::set_has_force() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbBody::clear_has_force() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbBody::clear_force() {
  if (force_ != NULL) force_->Clear();
  clear_has_force();
}
inline const ::box2d::PbVec2& PbBody::force() const {
  const ::box2d::PbVec2* p = force_;
  // @@protoc_insertion_point(field_get:box2d.PbBody.force)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbBody::release_force() {
  // @@protoc_insertion_point(field_release:box2d.PbBody.force)
  clear_has_force();
  ::box2d::PbVec2* temp = force_;
  force_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbBody::mutable_force() {
  set_has_force();
  if (force_ == NULL) {
    force_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbBody.force)
  return force_;
}
inline void PbBody::set_allocated_force(::box2d::PbVec2* force) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete force_;
  }
  if (force) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      force = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, force, submessage_arena);
    }
    set_has_force();
  } else {
    clear_has_force();
  }
  force_ = force;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbBody.force)
}

// optional float torque = 15;
inline bool PbBody::has_torque() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PbBody::set_has_torque() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PbBody::clear_has_torque() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PbBody::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline float PbBody::torque() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.torque)
  return torque_;
}
inline void PbBody::set_torque(float value) {
  set_has_torque();
  torque_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.torque)
}

// optional float mass = 16;
inline bool PbBody::has_mass() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PbBody::set_has_mass() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PbBody::clear_has_mass() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PbBody::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float PbBody::mass() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.mass)
  return mass_;
}
inline void PbBody::set_mass(float value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.mass)
}

// optional float I = 17;
inline bool PbBody::has_i() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PbBody::set_has_i() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PbBody::clear_has_i() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PbBody::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline float PbBody::i() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.I)
  return i_;
}
inline void PbBody::set_i(float value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.I)
}

// optional float linear_damping = 50;
inline bool PbBody::has_linear_damping() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PbBody::set_has_linear_damping() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PbBody::clear_has_linear_damping() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PbBody::clear_linear_damping() {
  linear_damping_ = 0;
  clear_has_linear_damping();
}
inline float PbBody::linear_damping() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.linear_damping)
  return linear_damping_;
}
inline void PbBody::set_linear_damping(float value) {
  set_has_linear_damping();
  linear_damping_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.linear_damping)
}

// optional float angular_damping = 51;
inline bool PbBody::has_angular_damping() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PbBody::set_has_angular_damping() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PbBody::clear_has_angular_damping() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PbBody::clear_angular_damping() {
  angular_damping_ = 0;
  clear_has_angular_damping();
}
inline float PbBody::angular_damping() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.angular_damping)
  return angular_damping_;
}
inline void PbBody::set_angular_damping(float value) {
  set_has_angular_damping();
  angular_damping_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.angular_damping)
}

// optional float gravity_scale = 52;
inline bool PbBody::has_gravity_scale() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PbBody::set_has_gravity_scale() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PbBody::clear_has_gravity_scale() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PbBody::clear_gravity_scale() {
  gravity_scale_ = 0;
  clear_has_gravity_scale();
}
inline float PbBody::gravity_scale() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.gravity_scale)
  return gravity_scale_;
}
inline void PbBody::set_gravity_scale(float value) {
  set_has_gravity_scale();
  gravity_scale_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.gravity_scale)
}

// optional bool bullet = 53;
inline bool PbBody::has_bullet() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PbBody::set_has_bullet() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PbBody::clear_has_bullet() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PbBody::clear_bullet() {
  bullet_ = false;
  clear_has_bullet();
}
inline bool PbBody::bullet() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.bullet)
  return bullet_;
}
inline void PbBody::set_bullet(bool value) {
  set_has_bullet();
  bullet_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.bullet)
}

// optional bool allow_sleep = 54;
inline bool PbBody::has_allow_sleep() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PbBody::set_has_allow_sleep() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PbBody::clear_has_allow_sleep() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PbBody::clear_allow_sleep() {
  allow_sleep_ = false;
  clear_has_allow_sleep();
}
inline bool PbBody::allow_sleep() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.allow_sleep)
  return allow_sleep_;
}
inline void PbBody::set_allow_sleep(bool value) {
  set_has_allow_sleep();
  allow_sleep_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.allow_sleep)
}

// optional bool awake = 55;
inline bool PbBody::has_awake() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PbBody::set_has_awake() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PbBody::clear_has_awake() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PbBody::clear_awake() {
  awake_ = false;
  clear_has_awake();
}
inline bool PbBody::awake() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.awake)
  return awake_;
}
inline void PbBody::set_awake(bool value) {
  set_has_awake();
  awake_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.awake)
}

// optional bool active = 56;
inline bool PbBody::has_active() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PbBody::set_has_active() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PbBody::clear_has_active() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PbBody::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool PbBody::active() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.active)
  return active_;
}
inline void PbBody::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.active)
}

// optional bool fixed_rotation = 57;
inline bool PbBody::has_fixed_rotation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PbBody::set_has_fixed_rotation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PbBody::clear_has_fixed_rotation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PbBody::clear_fixed_rotation() {
  fixed_rotation_ = false;
  clear_has_fixed_rotation();
}
inline bool PbBody::fixed_rotation() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.fixed_rotation)
  return fixed_rotation_;
}
inline void PbBody::set_fixed_rotation(bool value) {
  set_has_fixed_rotation();
  fixed_rotation_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbBody.fixed_rotation)
}

// optional string UUID = 60;
inline bool PbBody::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbBody::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbBody::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbBody::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& PbBody::uuid() const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.UUID)
  return uuid_.GetNoArena();
}
inline void PbBody::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:box2d.PbBody.UUID)
}
#if LANG_CXX11
inline void PbBody::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:box2d.PbBody.UUID)
}
#endif
inline void PbBody::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:box2d.PbBody.UUID)
}
inline void PbBody::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:box2d.PbBody.UUID)
}
inline ::std::string* PbBody::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:box2d.PbBody.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PbBody::release_uuid() {
  // @@protoc_insertion_point(field_release:box2d.PbBody.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PbBody::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:box2d.PbBody.UUID)
}

// repeated .box2d.PbFixture fixtures = 100;
inline int PbBody::fixtures_size() const {
  return fixtures_.size();
}
inline void PbBody::clear_fixtures() {
  fixtures_.Clear();
}
inline const ::box2d::PbFixture& PbBody::fixtures(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbBody.fixtures)
  return fixtures_.Get(index);
}
inline ::box2d::PbFixture* PbBody::mutable_fixtures(int index) {
  // @@protoc_insertion_point(field_mutable:box2d.PbBody.fixtures)
  return fixtures_.Mutable(index);
}
inline ::box2d::PbFixture* PbBody::add_fixtures() {
  // @@protoc_insertion_point(field_add:box2d.PbBody.fixtures)
  return fixtures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >*
PbBody::mutable_fixtures() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbBody.fixtures)
  return &fixtures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >&
PbBody::fixtures() const {
  // @@protoc_insertion_point(field_list:box2d.PbBody.fixtures)
  return fixtures_;
}

// -------------------------------------------------------------------

// PbWorld

// optional int64 tag = 1;
inline bool PbWorld::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbWorld::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbWorld::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbWorld::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbWorld::tag() const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.tag)
  return tag_;
}
inline void PbWorld::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbWorld.tag)
}

// optional .box2d.PbVec2 gravity = 2;
inline bool PbWorld::has_gravity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbWorld::set_has_gravity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbWorld::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbWorld::clear_gravity() {
  if (gravity_ != NULL) gravity_->Clear();
  clear_has_gravity();
}
inline const ::box2d::PbVec2& PbWorld::gravity() const {
  const ::box2d::PbVec2* p = gravity_;
  // @@protoc_insertion_point(field_get:box2d.PbWorld.gravity)
  return p != NULL ? *p : *reinterpret_cast<const ::box2d::PbVec2*>(
      &::box2d::_PbVec2_default_instance_);
}
inline ::box2d::PbVec2* PbWorld::release_gravity() {
  // @@protoc_insertion_point(field_release:box2d.PbWorld.gravity)
  clear_has_gravity();
  ::box2d::PbVec2* temp = gravity_;
  gravity_ = NULL;
  return temp;
}
inline ::box2d::PbVec2* PbWorld::mutable_gravity() {
  set_has_gravity();
  if (gravity_ == NULL) {
    gravity_ = new ::box2d::PbVec2;
  }
  // @@protoc_insertion_point(field_mutable:box2d.PbWorld.gravity)
  return gravity_;
}
inline void PbWorld::set_allocated_gravity(::box2d::PbVec2* gravity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gravity_;
  }
  if (gravity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gravity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gravity, submessage_arena);
    }
    set_has_gravity();
  } else {
    clear_has_gravity();
  }
  gravity_ = gravity;
  // @@protoc_insertion_point(field_set_allocated:box2d.PbWorld.gravity)
}

// optional bool allow_sleep = 3;
inline bool PbWorld::has_allow_sleep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbWorld::set_has_allow_sleep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbWorld::clear_has_allow_sleep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbWorld::clear_allow_sleep() {
  allow_sleep_ = false;
  clear_has_allow_sleep();
}
inline bool PbWorld::allow_sleep() const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.allow_sleep)
  return allow_sleep_;
}
inline void PbWorld::set_allow_sleep(bool value) {
  set_has_allow_sleep();
  allow_sleep_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbWorld.allow_sleep)
}

// optional bool auto_clear_forces = 4;
inline bool PbWorld::has_auto_clear_forces() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbWorld::set_has_auto_clear_forces() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbWorld::clear_has_auto_clear_forces() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbWorld::clear_auto_clear_forces() {
  auto_clear_forces_ = false;
  clear_has_auto_clear_forces();
}
inline bool PbWorld::auto_clear_forces() const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.auto_clear_forces)
  return auto_clear_forces_;
}
inline void PbWorld::set_auto_clear_forces(bool value) {
  set_has_auto_clear_forces();
  auto_clear_forces_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbWorld.auto_clear_forces)
}

// optional bool warm_starting = 5;
inline bool PbWorld::has_warm_starting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbWorld::set_has_warm_starting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbWorld::clear_has_warm_starting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbWorld::clear_warm_starting() {
  warm_starting_ = false;
  clear_has_warm_starting();
}
inline bool PbWorld::warm_starting() const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.warm_starting)
  return warm_starting_;
}
inline void PbWorld::set_warm_starting(bool value) {
  set_has_warm_starting();
  warm_starting_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbWorld.warm_starting)
}

// optional bool continuous_physics = 6;
inline bool PbWorld::has_continuous_physics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbWorld::set_has_continuous_physics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbWorld::clear_has_continuous_physics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbWorld::clear_continuous_physics() {
  continuous_physics_ = false;
  clear_has_continuous_physics();
}
inline bool PbWorld::continuous_physics() const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.continuous_physics)
  return continuous_physics_;
}
inline void PbWorld::set_continuous_physics(bool value) {
  set_has_continuous_physics();
  continuous_physics_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbWorld.continuous_physics)
}

// optional bool sub_stepping = 7;
inline bool PbWorld::has_sub_stepping() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbWorld::set_has_sub_stepping() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbWorld::clear_has_sub_stepping() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbWorld::clear_sub_stepping() {
  sub_stepping_ = false;
  clear_has_sub_stepping();
}
inline bool PbWorld::sub_stepping() const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.sub_stepping)
  return sub_stepping_;
}
inline void PbWorld::set_sub_stepping(bool value) {
  set_has_sub_stepping();
  sub_stepping_ = value;
  // @@protoc_insertion_point(field_set:box2d.PbWorld.sub_stepping)
}

// repeated .box2d.PbBody bodies = 20;
inline int PbWorld::bodies_size() const {
  return bodies_.size();
}
inline void PbWorld::clear_bodies() {
  bodies_.Clear();
}
inline const ::box2d::PbBody& PbWorld::bodies(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.bodies)
  return bodies_.Get(index);
}
inline ::box2d::PbBody* PbWorld::mutable_bodies(int index) {
  // @@protoc_insertion_point(field_mutable:box2d.PbWorld.bodies)
  return bodies_.Mutable(index);
}
inline ::box2d::PbBody* PbWorld::add_bodies() {
  // @@protoc_insertion_point(field_add:box2d.PbWorld.bodies)
  return bodies_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >*
PbWorld::mutable_bodies() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbWorld.bodies)
  return &bodies_;
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >&
PbWorld::bodies() const {
  // @@protoc_insertion_point(field_list:box2d.PbWorld.bodies)
  return bodies_;
}

// repeated .box2d.PbJoint joints = 21;
inline int PbWorld::joints_size() const {
  return joints_.size();
}
inline void PbWorld::clear_joints() {
  joints_.Clear();
}
inline const ::box2d::PbJoint& PbWorld::joints(int index) const {
  // @@protoc_insertion_point(field_get:box2d.PbWorld.joints)
  return joints_.Get(index);
}
inline ::box2d::PbJoint* PbWorld::mutable_joints(int index) {
  // @@protoc_insertion_point(field_mutable:box2d.PbWorld.joints)
  return joints_.Mutable(index);
}
inline ::box2d::PbJoint* PbWorld::add_joints() {
  // @@protoc_insertion_point(field_add:box2d.PbWorld.joints)
  return joints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >*
PbWorld::mutable_joints() {
  // @@protoc_insertion_point(field_mutable_list:box2d.PbWorld.joints)
  return &joints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >&
PbWorld::joints() const {
  // @@protoc_insertion_point(field_list:box2d.PbWorld.joints)
  return joints_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace box2d

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::box2d::PbBodyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::box2d::PbBodyType>() {
  return ::box2d::PbBodyType_descriptor();
}
template <> struct is_proto_enum< ::box2d::PbShapeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::box2d::PbShapeType>() {
  return ::box2d::PbShapeType_descriptor();
}
template <> struct is_proto_enum< ::box2d::PbJointType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::box2d::PbJointType>() {
  return ::box2d::PbJointType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_box2d_2eproto__INCLUDED
