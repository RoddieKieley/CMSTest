// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: box2d.proto

#ifndef PROTOBUF_box2d_2eproto__INCLUDED
#define PROTOBUF_box2d_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace box2d {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_box2d_2eproto();
void protobuf_AssignDesc_box2d_2eproto();
void protobuf_ShutdownFile_box2d_2eproto();

class PbVec2;
class PbFilter;
class PbShape;
class PbFixture;
class PbJoint;
class PbBody;
class PbWorld;

enum PbBodyType {
  STATIC = 0,
  DYNAMIC = 1,
  KINEMATIC = 2
};
bool PbBodyType_IsValid(int value);
const PbBodyType PbBodyType_MIN = STATIC;
const PbBodyType PbBodyType_MAX = KINEMATIC;
const int PbBodyType_ARRAYSIZE = PbBodyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbBodyType_descriptor();
inline const ::std::string& PbBodyType_Name(PbBodyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbBodyType_descriptor(), value);
}
inline bool PbBodyType_Parse(
    const ::std::string& name, PbBodyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbBodyType>(
    PbBodyType_descriptor(), name, value);
}
enum PbShapeType {
  CIRCLE = 1,
  POLYGON = 2,
  EDGE = 3,
  LOOP = 4
};
bool PbShapeType_IsValid(int value);
const PbShapeType PbShapeType_MIN = CIRCLE;
const PbShapeType PbShapeType_MAX = LOOP;
const int PbShapeType_ARRAYSIZE = PbShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbShapeType_descriptor();
inline const ::std::string& PbShapeType_Name(PbShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbShapeType_descriptor(), value);
}
inline bool PbShapeType_Parse(
    const ::std::string& name, PbShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbShapeType>(
    PbShapeType_descriptor(), name, value);
}
enum PbJointType {
  DISTANCE = 1,
  REVOLUTE = 2,
  PRISMATIC = 3,
  PULLEY = 4,
  MOUSE = 5,
  GEAR = 6,
  WHEEL = 7,
  WELD = 8,
  FRICTION = 9,
  ROPE = 10,
  CONSTANT_VOLUME = 11,
  LINE = 12
};
bool PbJointType_IsValid(int value);
const PbJointType PbJointType_MIN = DISTANCE;
const PbJointType PbJointType_MAX = LINE;
const int PbJointType_ARRAYSIZE = PbJointType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbJointType_descriptor();
inline const ::std::string& PbJointType_Name(PbJointType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbJointType_descriptor(), value);
}
inline bool PbJointType_Parse(
    const ::std::string& name, PbJointType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbJointType>(
    PbJointType_descriptor(), name, value);
}
// ===================================================================

class PbVec2 : public ::google::protobuf::Message {
 public:
  PbVec2();
  virtual ~PbVec2();

  PbVec2(const PbVec2& from);

  inline PbVec2& operator=(const PbVec2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbVec2& default_instance();

  void Swap(PbVec2* other);

  // implements Message ----------------------------------------------

  PbVec2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbVec2& from);
  void MergeFrom(const PbVec2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:box2d.PbVec2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbVec2* default_instance_;
};
// -------------------------------------------------------------------

class PbFilter : public ::google::protobuf::Message {
 public:
  PbFilter();
  virtual ~PbFilter();

  PbFilter(const PbFilter& from);

  inline PbFilter& operator=(const PbFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbFilter& default_instance();

  void Swap(PbFilter* other);

  // implements Message ----------------------------------------------

  PbFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbFilter& from);
  void MergeFrom(const PbFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 category_bits = 1;
  inline bool has_category_bits() const;
  inline void clear_category_bits();
  static const int kCategoryBitsFieldNumber = 1;
  inline ::google::protobuf::int32 category_bits() const;
  inline void set_category_bits(::google::protobuf::int32 value);

  // optional int32 mask_bits = 2;
  inline bool has_mask_bits() const;
  inline void clear_mask_bits();
  static const int kMaskBitsFieldNumber = 2;
  inline ::google::protobuf::int32 mask_bits() const;
  inline void set_mask_bits(::google::protobuf::int32 value);

  // optional int32 group_index = 3;
  inline bool has_group_index() const;
  inline void clear_group_index();
  static const int kGroupIndexFieldNumber = 3;
  inline ::google::protobuf::int32 group_index() const;
  inline void set_group_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:box2d.PbFilter)
 private:
  inline void set_has_category_bits();
  inline void clear_has_category_bits();
  inline void set_has_mask_bits();
  inline void clear_has_mask_bits();
  inline void set_has_group_index();
  inline void clear_has_group_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 category_bits_;
  ::google::protobuf::int32 mask_bits_;
  ::google::protobuf::int32 group_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbFilter* default_instance_;
};
// -------------------------------------------------------------------

class PbShape : public ::google::protobuf::Message {
 public:
  PbShape();
  virtual ~PbShape();

  PbShape(const PbShape& from);

  inline PbShape& operator=(const PbShape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbShape& default_instance();

  void Swap(PbShape* other);

  // implements Message ----------------------------------------------

  PbShape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbShape& from);
  void MergeFrom(const PbShape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::google::protobuf::int64 tag() const;
  inline void set_tag(::google::protobuf::int64 value);

  // required .box2d.PbShapeType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::box2d::PbShapeType type() const;
  inline void set_type(::box2d::PbShapeType value);

  // optional .box2d.PbVec2 center = 10;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 10;
  inline const ::box2d::PbVec2& center() const;
  inline ::box2d::PbVec2* mutable_center();
  inline ::box2d::PbVec2* release_center();
  inline void set_allocated_center(::box2d::PbVec2* center);

  // optional float radius = 11;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 11;
  inline float radius() const;
  inline void set_radius(float value);

  // repeated .box2d.PbVec2 points = 20;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 20;
  inline const ::box2d::PbVec2& points(int index) const;
  inline ::box2d::PbVec2* mutable_points(int index);
  inline ::box2d::PbVec2* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
      mutable_points();

  // repeated .box2d.PbVec2 normals = 21;
  inline int normals_size() const;
  inline void clear_normals();
  static const int kNormalsFieldNumber = 21;
  inline const ::box2d::PbVec2& normals(int index) const;
  inline ::box2d::PbVec2* mutable_normals(int index);
  inline ::box2d::PbVec2* add_normals();
  inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
      normals() const;
  inline ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
      mutable_normals();

  // optional .box2d.PbVec2 centroid = 22;
  inline bool has_centroid() const;
  inline void clear_centroid();
  static const int kCentroidFieldNumber = 22;
  inline const ::box2d::PbVec2& centroid() const;
  inline ::box2d::PbVec2* mutable_centroid();
  inline ::box2d::PbVec2* release_centroid();
  inline void set_allocated_centroid(::box2d::PbVec2* centroid);

  // @@protoc_insertion_point(class_scope:box2d.PbShape)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_centroid();
  inline void clear_has_centroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tag_;
  ::box2d::PbVec2* center_;
  int type_;
  float radius_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 > points_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 > normals_;
  ::box2d::PbVec2* centroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbShape* default_instance_;
};
// -------------------------------------------------------------------

class PbFixture : public ::google::protobuf::Message {
 public:
  PbFixture();
  virtual ~PbFixture();

  PbFixture(const PbFixture& from);

  inline PbFixture& operator=(const PbFixture& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbFixture& default_instance();

  void Swap(PbFixture* other);

  // implements Message ----------------------------------------------

  PbFixture* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbFixture& from);
  void MergeFrom(const PbFixture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::google::protobuf::int64 tag() const;
  inline void set_tag(::google::protobuf::int64 value);

  // optional float restitution = 2;
  inline bool has_restitution() const;
  inline void clear_restitution();
  static const int kRestitutionFieldNumber = 2;
  inline float restitution() const;
  inline void set_restitution(float value);

  // optional float friction = 3;
  inline bool has_friction() const;
  inline void clear_friction();
  static const int kFrictionFieldNumber = 3;
  inline float friction() const;
  inline void set_friction(float value);

  // optional float density = 4;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 4;
  inline float density() const;
  inline void set_density(float value);

  // optional bool sensor = 5;
  inline bool has_sensor() const;
  inline void clear_sensor();
  static const int kSensorFieldNumber = 5;
  inline bool sensor() const;
  inline void set_sensor(bool value);

  // optional .box2d.PbFilter filter = 10;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 10;
  inline const ::box2d::PbFilter& filter() const;
  inline ::box2d::PbFilter* mutable_filter();
  inline ::box2d::PbFilter* release_filter();
  inline void set_allocated_filter(::box2d::PbFilter* filter);

  // optional .box2d.PbShape shape = 11;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 11;
  inline const ::box2d::PbShape& shape() const;
  inline ::box2d::PbShape* mutable_shape();
  inline ::box2d::PbShape* release_shape();
  inline void set_allocated_shape(::box2d::PbShape* shape);

  // @@protoc_insertion_point(class_scope:box2d.PbFixture)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_restitution();
  inline void clear_has_restitution();
  inline void set_has_friction();
  inline void clear_has_friction();
  inline void set_has_density();
  inline void clear_has_density();
  inline void set_has_sensor();
  inline void clear_has_sensor();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_shape();
  inline void clear_has_shape();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tag_;
  float restitution_;
  float friction_;
  float density_;
  bool sensor_;
  ::box2d::PbFilter* filter_;
  ::box2d::PbShape* shape_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbFixture* default_instance_;
};
// -------------------------------------------------------------------

class PbJoint : public ::google::protobuf::Message {
 public:
  PbJoint();
  virtual ~PbJoint();

  PbJoint(const PbJoint& from);

  inline PbJoint& operator=(const PbJoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbJoint& default_instance();

  void Swap(PbJoint* other);

  // implements Message ----------------------------------------------

  PbJoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbJoint& from);
  void MergeFrom(const PbJoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::google::protobuf::int64 tag() const;
  inline void set_tag(::google::protobuf::int64 value);

  // required .box2d.PbJointType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::box2d::PbJointType type() const;
  inline void set_type(::box2d::PbJointType value);

  // optional int32 body_a = 3;
  inline bool has_body_a() const;
  inline void clear_body_a();
  static const int kBodyAFieldNumber = 3;
  inline ::google::protobuf::int32 body_a() const;
  inline void set_body_a(::google::protobuf::int32 value);

  // optional int32 body_b = 4;
  inline bool has_body_b() const;
  inline void clear_body_b();
  static const int kBodyBFieldNumber = 4;
  inline ::google::protobuf::int32 body_b() const;
  inline void set_body_b(::google::protobuf::int32 value);

  // optional bool collideConnected = 5;
  inline bool has_collideconnected() const;
  inline void clear_collideconnected();
  static const int kCollideConnectedFieldNumber = 5;
  inline bool collideconnected() const;
  inline void set_collideconnected(bool value);

  // optional .box2d.PbVec2 local_anchor_a = 6;
  inline bool has_local_anchor_a() const;
  inline void clear_local_anchor_a();
  static const int kLocalAnchorAFieldNumber = 6;
  inline const ::box2d::PbVec2& local_anchor_a() const;
  inline ::box2d::PbVec2* mutable_local_anchor_a();
  inline ::box2d::PbVec2* release_local_anchor_a();
  inline void set_allocated_local_anchor_a(::box2d::PbVec2* local_anchor_a);

  // optional .box2d.PbVec2 local_anchor_b = 7;
  inline bool has_local_anchor_b() const;
  inline void clear_local_anchor_b();
  static const int kLocalAnchorBFieldNumber = 7;
  inline const ::box2d::PbVec2& local_anchor_b() const;
  inline ::box2d::PbVec2* mutable_local_anchor_b();
  inline ::box2d::PbVec2* release_local_anchor_b();
  inline void set_allocated_local_anchor_b(::box2d::PbVec2* local_anchor_b);

  // optional float ref_angle = 10;
  inline bool has_ref_angle() const;
  inline void clear_ref_angle();
  static const int kRefAngleFieldNumber = 10;
  inline float ref_angle() const;
  inline void set_ref_angle(float value);

  // optional bool enable_limit = 12;
  inline bool has_enable_limit() const;
  inline void clear_enable_limit();
  static const int kEnableLimitFieldNumber = 12;
  inline bool enable_limit() const;
  inline void set_enable_limit(bool value);

  // optional float lower_limit = 13;
  inline bool has_lower_limit() const;
  inline void clear_lower_limit();
  static const int kLowerLimitFieldNumber = 13;
  inline float lower_limit() const;
  inline void set_lower_limit(float value);

  // optional float upper_limit = 14;
  inline bool has_upper_limit() const;
  inline void clear_upper_limit();
  static const int kUpperLimitFieldNumber = 14;
  inline float upper_limit() const;
  inline void set_upper_limit(float value);

  // optional bool enable_motor = 15;
  inline bool has_enable_motor() const;
  inline void clear_enable_motor();
  static const int kEnableMotorFieldNumber = 15;
  inline bool enable_motor() const;
  inline void set_enable_motor(bool value);

  // optional float motor_speed = 16;
  inline bool has_motor_speed() const;
  inline void clear_motor_speed();
  static const int kMotorSpeedFieldNumber = 16;
  inline float motor_speed() const;
  inline void set_motor_speed(float value);

  // optional float max_motor_torque = 17;
  inline bool has_max_motor_torque() const;
  inline void clear_max_motor_torque();
  static const int kMaxMotorTorqueFieldNumber = 17;
  inline float max_motor_torque() const;
  inline void set_max_motor_torque(float value);

  // optional .box2d.PbVec2 local_axis_a = 20;
  inline bool has_local_axis_a() const;
  inline void clear_local_axis_a();
  static const int kLocalAxisAFieldNumber = 20;
  inline const ::box2d::PbVec2& local_axis_a() const;
  inline ::box2d::PbVec2* mutable_local_axis_a();
  inline ::box2d::PbVec2* release_local_axis_a();
  inline void set_allocated_local_axis_a(::box2d::PbVec2* local_axis_a);

  // optional float max_motor_force = 21;
  inline bool has_max_motor_force() const;
  inline void clear_max_motor_force();
  static const int kMaxMotorForceFieldNumber = 21;
  inline float max_motor_force() const;
  inline void set_max_motor_force(float value);

  // optional float length = 30;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 30;
  inline float length() const;
  inline void set_length(float value);

  // optional float frequency = 31;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 31;
  inline float frequency() const;
  inline void set_frequency(float value);

  // optional float damping_ratio = 32;
  inline bool has_damping_ratio() const;
  inline void clear_damping_ratio();
  static const int kDampingRatioFieldNumber = 32;
  inline float damping_ratio() const;
  inline void set_damping_ratio(float value);

  // optional .box2d.PbVec2 ground_anchor_a = 40;
  inline bool has_ground_anchor_a() const;
  inline void clear_ground_anchor_a();
  static const int kGroundAnchorAFieldNumber = 40;
  inline const ::box2d::PbVec2& ground_anchor_a() const;
  inline ::box2d::PbVec2* mutable_ground_anchor_a();
  inline ::box2d::PbVec2* release_ground_anchor_a();
  inline void set_allocated_ground_anchor_a(::box2d::PbVec2* ground_anchor_a);

  // optional .box2d.PbVec2 ground_anchor_b = 41;
  inline bool has_ground_anchor_b() const;
  inline void clear_ground_anchor_b();
  static const int kGroundAnchorBFieldNumber = 41;
  inline const ::box2d::PbVec2& ground_anchor_b() const;
  inline ::box2d::PbVec2* mutable_ground_anchor_b();
  inline ::box2d::PbVec2* release_ground_anchor_b();
  inline void set_allocated_ground_anchor_b(::box2d::PbVec2* ground_anchor_b);

  // optional float length_a = 42;
  inline bool has_length_a() const;
  inline void clear_length_a();
  static const int kLengthAFieldNumber = 42;
  inline float length_a() const;
  inline void set_length_a(float value);

  // optional float length_b = 43;
  inline bool has_length_b() const;
  inline void clear_length_b();
  static const int kLengthBFieldNumber = 43;
  inline float length_b() const;
  inline void set_length_b(float value);

  // optional float ratio = 44;
  inline bool has_ratio() const;
  inline void clear_ratio();
  static const int kRatioFieldNumber = 44;
  inline float ratio() const;
  inline void set_ratio(float value);

  // optional float max_length_a = 45;
  inline bool has_max_length_a() const;
  inline void clear_max_length_a();
  static const int kMaxLengthAFieldNumber = 45;
  inline float max_length_a() const;
  inline void set_max_length_a(float value);

  // optional float max_length_b = 46;
  inline bool has_max_length_b() const;
  inline void clear_max_length_b();
  static const int kMaxLengthBFieldNumber = 46;
  inline float max_length_b() const;
  inline void set_max_length_b(float value);

  // optional .box2d.PbVec2 target = 50;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 50;
  inline const ::box2d::PbVec2& target() const;
  inline ::box2d::PbVec2* mutable_target();
  inline ::box2d::PbVec2* release_target();
  inline void set_allocated_target(::box2d::PbVec2* target);

  // optional float max_force = 51;
  inline bool has_max_force() const;
  inline void clear_max_force();
  static const int kMaxForceFieldNumber = 51;
  inline float max_force() const;
  inline void set_max_force(float value);

  // optional int32 joint1 = 61;
  inline bool has_joint1() const;
  inline void clear_joint1();
  static const int kJoint1FieldNumber = 61;
  inline ::google::protobuf::int32 joint1() const;
  inline void set_joint1(::google::protobuf::int32 value);

  // optional int32 joint2 = 62;
  inline bool has_joint2() const;
  inline void clear_joint2();
  static const int kJoint2FieldNumber = 62;
  inline ::google::protobuf::int32 joint2() const;
  inline void set_joint2(::google::protobuf::int32 value);

  // optional float spring_frequency = 70;
  inline bool has_spring_frequency() const;
  inline void clear_spring_frequency();
  static const int kSpringFrequencyFieldNumber = 70;
  inline float spring_frequency() const;
  inline void set_spring_frequency(float value);

  // optional float spring_damping_ratio = 71;
  inline bool has_spring_damping_ratio() const;
  inline void clear_spring_damping_ratio();
  static const int kSpringDampingRatioFieldNumber = 71;
  inline float spring_damping_ratio() const;
  inline void set_spring_damping_ratio(float value);

  // optional float max_torque = 90;
  inline bool has_max_torque() const;
  inline void clear_max_torque();
  static const int kMaxTorqueFieldNumber = 90;
  inline float max_torque() const;
  inline void set_max_torque(float value);

  // optional float max_length = 100;
  inline bool has_max_length() const;
  inline void clear_max_length();
  static const int kMaxLengthFieldNumber = 100;
  inline float max_length() const;
  inline void set_max_length(float value);

  // repeated int32 bodies = 110;
  inline int bodies_size() const;
  inline void clear_bodies();
  static const int kBodiesFieldNumber = 110;
  inline ::google::protobuf::int32 bodies(int index) const;
  inline void set_bodies(int index, ::google::protobuf::int32 value);
  inline void add_bodies(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bodies() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bodies();

  // repeated int32 joints = 111;
  inline int joints_size() const;
  inline void clear_joints();
  static const int kJointsFieldNumber = 111;
  inline ::google::protobuf::int32 joints(int index) const;
  inline void set_joints(int index, ::google::protobuf::int32 value);
  inline void add_joints(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      joints() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_joints();

  // optional float target_volume = 112;
  inline bool has_target_volume() const;
  inline void clear_target_volume();
  static const int kTargetVolumeFieldNumber = 112;
  inline float target_volume() const;
  inline void set_target_volume(float value);

  // @@protoc_insertion_point(class_scope:box2d.PbJoint)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_body_a();
  inline void clear_has_body_a();
  inline void set_has_body_b();
  inline void clear_has_body_b();
  inline void set_has_collideconnected();
  inline void clear_has_collideconnected();
  inline void set_has_local_anchor_a();
  inline void clear_has_local_anchor_a();
  inline void set_has_local_anchor_b();
  inline void clear_has_local_anchor_b();
  inline void set_has_ref_angle();
  inline void clear_has_ref_angle();
  inline void set_has_enable_limit();
  inline void clear_has_enable_limit();
  inline void set_has_lower_limit();
  inline void clear_has_lower_limit();
  inline void set_has_upper_limit();
  inline void clear_has_upper_limit();
  inline void set_has_enable_motor();
  inline void clear_has_enable_motor();
  inline void set_has_motor_speed();
  inline void clear_has_motor_speed();
  inline void set_has_max_motor_torque();
  inline void clear_has_max_motor_torque();
  inline void set_has_local_axis_a();
  inline void clear_has_local_axis_a();
  inline void set_has_max_motor_force();
  inline void clear_has_max_motor_force();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_damping_ratio();
  inline void clear_has_damping_ratio();
  inline void set_has_ground_anchor_a();
  inline void clear_has_ground_anchor_a();
  inline void set_has_ground_anchor_b();
  inline void clear_has_ground_anchor_b();
  inline void set_has_length_a();
  inline void clear_has_length_a();
  inline void set_has_length_b();
  inline void clear_has_length_b();
  inline void set_has_ratio();
  inline void clear_has_ratio();
  inline void set_has_max_length_a();
  inline void clear_has_max_length_a();
  inline void set_has_max_length_b();
  inline void clear_has_max_length_b();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_max_force();
  inline void clear_has_max_force();
  inline void set_has_joint1();
  inline void clear_has_joint1();
  inline void set_has_joint2();
  inline void clear_has_joint2();
  inline void set_has_spring_frequency();
  inline void clear_has_spring_frequency();
  inline void set_has_spring_damping_ratio();
  inline void clear_has_spring_damping_ratio();
  inline void set_has_max_torque();
  inline void clear_has_max_torque();
  inline void set_has_max_length();
  inline void clear_has_max_length();
  inline void set_has_target_volume();
  inline void clear_has_target_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tag_;
  int type_;
  ::google::protobuf::int32 body_a_;
  ::box2d::PbVec2* local_anchor_a_;
  ::google::protobuf::int32 body_b_;
  float ref_angle_;
  ::box2d::PbVec2* local_anchor_b_;
  bool collideconnected_;
  bool enable_limit_;
  bool enable_motor_;
  float lower_limit_;
  float upper_limit_;
  float motor_speed_;
  ::box2d::PbVec2* local_axis_a_;
  float max_motor_torque_;
  float max_motor_force_;
  float length_;
  float frequency_;
  ::box2d::PbVec2* ground_anchor_a_;
  float damping_ratio_;
  float length_a_;
  ::box2d::PbVec2* ground_anchor_b_;
  float length_b_;
  float ratio_;
  float max_length_a_;
  float max_length_b_;
  ::box2d::PbVec2* target_;
  float max_force_;
  ::google::protobuf::int32 joint1_;
  ::google::protobuf::int32 joint2_;
  float spring_frequency_;
  float spring_damping_ratio_;
  float max_torque_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bodies_;
  float max_length_;
  float target_volume_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > joints_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbJoint* default_instance_;
};
// -------------------------------------------------------------------

class PbBody : public ::google::protobuf::Message {
 public:
  PbBody();
  virtual ~PbBody();

  PbBody(const PbBody& from);

  inline PbBody& operator=(const PbBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbBody& default_instance();

  void Swap(PbBody* other);

  // implements Message ----------------------------------------------

  PbBody* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbBody& from);
  void MergeFrom(const PbBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::google::protobuf::int64 tag() const;
  inline void set_tag(::google::protobuf::int64 value);

  // required .box2d.PbBodyType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::box2d::PbBodyType type() const;
  inline void set_type(::box2d::PbBodyType value);

  // optional .box2d.PbVec2 position = 10;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 10;
  inline const ::box2d::PbVec2& position() const;
  inline ::box2d::PbVec2* mutable_position();
  inline ::box2d::PbVec2* release_position();
  inline void set_allocated_position(::box2d::PbVec2* position);

  // optional float angle = 11;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 11;
  inline float angle() const;
  inline void set_angle(float value);

  // optional .box2d.PbVec2 linear_velocity = 12;
  inline bool has_linear_velocity() const;
  inline void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 12;
  inline const ::box2d::PbVec2& linear_velocity() const;
  inline ::box2d::PbVec2* mutable_linear_velocity();
  inline ::box2d::PbVec2* release_linear_velocity();
  inline void set_allocated_linear_velocity(::box2d::PbVec2* linear_velocity);

  // optional float angular_velocity = 13;
  inline bool has_angular_velocity() const;
  inline void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 13;
  inline float angular_velocity() const;
  inline void set_angular_velocity(float value);

  // optional .box2d.PbVec2 force = 14;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 14;
  inline const ::box2d::PbVec2& force() const;
  inline ::box2d::PbVec2* mutable_force();
  inline ::box2d::PbVec2* release_force();
  inline void set_allocated_force(::box2d::PbVec2* force);

  // optional float torque = 15;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 15;
  inline float torque() const;
  inline void set_torque(float value);

  // optional float mass = 16;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 16;
  inline float mass() const;
  inline void set_mass(float value);

  // optional float I = 17;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 17;
  inline float i() const;
  inline void set_i(float value);

  // optional float linear_damping = 50;
  inline bool has_linear_damping() const;
  inline void clear_linear_damping();
  static const int kLinearDampingFieldNumber = 50;
  inline float linear_damping() const;
  inline void set_linear_damping(float value);

  // optional float angular_damping = 51;
  inline bool has_angular_damping() const;
  inline void clear_angular_damping();
  static const int kAngularDampingFieldNumber = 51;
  inline float angular_damping() const;
  inline void set_angular_damping(float value);

  // optional float gravity_scale = 52;
  inline bool has_gravity_scale() const;
  inline void clear_gravity_scale();
  static const int kGravityScaleFieldNumber = 52;
  inline float gravity_scale() const;
  inline void set_gravity_scale(float value);

  // optional bool bullet = 53;
  inline bool has_bullet() const;
  inline void clear_bullet();
  static const int kBulletFieldNumber = 53;
  inline bool bullet() const;
  inline void set_bullet(bool value);

  // optional bool allow_sleep = 54;
  inline bool has_allow_sleep() const;
  inline void clear_allow_sleep();
  static const int kAllowSleepFieldNumber = 54;
  inline bool allow_sleep() const;
  inline void set_allow_sleep(bool value);

  // optional bool awake = 55;
  inline bool has_awake() const;
  inline void clear_awake();
  static const int kAwakeFieldNumber = 55;
  inline bool awake() const;
  inline void set_awake(bool value);

  // optional bool active = 56;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 56;
  inline bool active() const;
  inline void set_active(bool value);

  // optional bool fixed_rotation = 57;
  inline bool has_fixed_rotation() const;
  inline void clear_fixed_rotation();
  static const int kFixedRotationFieldNumber = 57;
  inline bool fixed_rotation() const;
  inline void set_fixed_rotation(bool value);

  // repeated .box2d.PbFixture fixtures = 100;
  inline int fixtures_size() const;
  inline void clear_fixtures();
  static const int kFixturesFieldNumber = 100;
  inline const ::box2d::PbFixture& fixtures(int index) const;
  inline ::box2d::PbFixture* mutable_fixtures(int index);
  inline ::box2d::PbFixture* add_fixtures();
  inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >&
      fixtures() const;
  inline ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >*
      mutable_fixtures();

  // @@protoc_insertion_point(class_scope:box2d.PbBody)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_linear_velocity();
  inline void clear_has_linear_velocity();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_linear_damping();
  inline void clear_has_linear_damping();
  inline void set_has_angular_damping();
  inline void clear_has_angular_damping();
  inline void set_has_gravity_scale();
  inline void clear_has_gravity_scale();
  inline void set_has_bullet();
  inline void clear_has_bullet();
  inline void set_has_allow_sleep();
  inline void clear_has_allow_sleep();
  inline void set_has_awake();
  inline void clear_has_awake();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_fixed_rotation();
  inline void clear_has_fixed_rotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tag_;
  ::box2d::PbVec2* position_;
  int type_;
  float angle_;
  ::box2d::PbVec2* linear_velocity_;
  ::box2d::PbVec2* force_;
  float angular_velocity_;
  float torque_;
  float mass_;
  float i_;
  float linear_damping_;
  float angular_damping_;
  float gravity_scale_;
  bool bullet_;
  bool allow_sleep_;
  bool awake_;
  bool active_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture > fixtures_;
  bool fixed_rotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbBody* default_instance_;
};
// -------------------------------------------------------------------

class PbWorld : public ::google::protobuf::Message {
 public:
  PbWorld();
  virtual ~PbWorld();

  PbWorld(const PbWorld& from);

  inline PbWorld& operator=(const PbWorld& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbWorld& default_instance();

  void Swap(PbWorld* other);

  // implements Message ----------------------------------------------

  PbWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbWorld& from);
  void MergeFrom(const PbWorld& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tag = 1;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 1;
  inline ::google::protobuf::int64 tag() const;
  inline void set_tag(::google::protobuf::int64 value);

  // optional .box2d.PbVec2 gravity = 2;
  inline bool has_gravity() const;
  inline void clear_gravity();
  static const int kGravityFieldNumber = 2;
  inline const ::box2d::PbVec2& gravity() const;
  inline ::box2d::PbVec2* mutable_gravity();
  inline ::box2d::PbVec2* release_gravity();
  inline void set_allocated_gravity(::box2d::PbVec2* gravity);

  // optional bool allow_sleep = 3;
  inline bool has_allow_sleep() const;
  inline void clear_allow_sleep();
  static const int kAllowSleepFieldNumber = 3;
  inline bool allow_sleep() const;
  inline void set_allow_sleep(bool value);

  // optional bool auto_clear_forces = 4;
  inline bool has_auto_clear_forces() const;
  inline void clear_auto_clear_forces();
  static const int kAutoClearForcesFieldNumber = 4;
  inline bool auto_clear_forces() const;
  inline void set_auto_clear_forces(bool value);

  // optional bool warm_starting = 5;
  inline bool has_warm_starting() const;
  inline void clear_warm_starting();
  static const int kWarmStartingFieldNumber = 5;
  inline bool warm_starting() const;
  inline void set_warm_starting(bool value);

  // optional bool continuous_physics = 6;
  inline bool has_continuous_physics() const;
  inline void clear_continuous_physics();
  static const int kContinuousPhysicsFieldNumber = 6;
  inline bool continuous_physics() const;
  inline void set_continuous_physics(bool value);

  // optional bool sub_stepping = 7;
  inline bool has_sub_stepping() const;
  inline void clear_sub_stepping();
  static const int kSubSteppingFieldNumber = 7;
  inline bool sub_stepping() const;
  inline void set_sub_stepping(bool value);

  // repeated .box2d.PbBody bodies = 20;
  inline int bodies_size() const;
  inline void clear_bodies();
  static const int kBodiesFieldNumber = 20;
  inline const ::box2d::PbBody& bodies(int index) const;
  inline ::box2d::PbBody* mutable_bodies(int index);
  inline ::box2d::PbBody* add_bodies();
  inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >&
      bodies() const;
  inline ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >*
      mutable_bodies();

  // repeated .box2d.PbJoint joints = 21;
  inline int joints_size() const;
  inline void clear_joints();
  static const int kJointsFieldNumber = 21;
  inline const ::box2d::PbJoint& joints(int index) const;
  inline ::box2d::PbJoint* mutable_joints(int index);
  inline ::box2d::PbJoint* add_joints();
  inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >&
      joints() const;
  inline ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >*
      mutable_joints();

  // @@protoc_insertion_point(class_scope:box2d.PbWorld)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_gravity();
  inline void clear_has_gravity();
  inline void set_has_allow_sleep();
  inline void clear_has_allow_sleep();
  inline void set_has_auto_clear_forces();
  inline void clear_has_auto_clear_forces();
  inline void set_has_warm_starting();
  inline void clear_has_warm_starting();
  inline void set_has_continuous_physics();
  inline void clear_has_continuous_physics();
  inline void set_has_sub_stepping();
  inline void clear_has_sub_stepping();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tag_;
  ::box2d::PbVec2* gravity_;
  bool allow_sleep_;
  bool auto_clear_forces_;
  bool warm_starting_;
  bool continuous_physics_;
  bool sub_stepping_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbBody > bodies_;
  ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint > joints_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_box2d_2eproto();
  friend void protobuf_AssignDesc_box2d_2eproto();
  friend void protobuf_ShutdownFile_box2d_2eproto();

  void InitAsDefaultInstance();
  static PbWorld* default_instance_;
};
// ===================================================================


// ===================================================================

// PbVec2

// required float x = 1;
inline bool PbVec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbVec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbVec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbVec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PbVec2::x() const {
  return x_;
}
inline void PbVec2::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool PbVec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbVec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbVec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbVec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PbVec2::y() const {
  return y_;
}
inline void PbVec2::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// PbFilter

// optional int32 category_bits = 1;
inline bool PbFilter::has_category_bits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbFilter::set_has_category_bits() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbFilter::clear_has_category_bits() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbFilter::clear_category_bits() {
  category_bits_ = 0;
  clear_has_category_bits();
}
inline ::google::protobuf::int32 PbFilter::category_bits() const {
  return category_bits_;
}
inline void PbFilter::set_category_bits(::google::protobuf::int32 value) {
  set_has_category_bits();
  category_bits_ = value;
}

// optional int32 mask_bits = 2;
inline bool PbFilter::has_mask_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbFilter::set_has_mask_bits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbFilter::clear_has_mask_bits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbFilter::clear_mask_bits() {
  mask_bits_ = 0;
  clear_has_mask_bits();
}
inline ::google::protobuf::int32 PbFilter::mask_bits() const {
  return mask_bits_;
}
inline void PbFilter::set_mask_bits(::google::protobuf::int32 value) {
  set_has_mask_bits();
  mask_bits_ = value;
}

// optional int32 group_index = 3;
inline bool PbFilter::has_group_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbFilter::set_has_group_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbFilter::clear_has_group_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbFilter::clear_group_index() {
  group_index_ = 0;
  clear_has_group_index();
}
inline ::google::protobuf::int32 PbFilter::group_index() const {
  return group_index_;
}
inline void PbFilter::set_group_index(::google::protobuf::int32 value) {
  set_has_group_index();
  group_index_ = value;
}

// -------------------------------------------------------------------

// PbShape

// optional int64 tag = 1;
inline bool PbShape::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbShape::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbShape::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbShape::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbShape::tag() const {
  return tag_;
}
inline void PbShape::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
}

// required .box2d.PbShapeType type = 2;
inline bool PbShape::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbShape::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbShape::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbShape::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::box2d::PbShapeType PbShape::type() const {
  return static_cast< ::box2d::PbShapeType >(type_);
}
inline void PbShape::set_type(::box2d::PbShapeType value) {
  assert(::box2d::PbShapeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .box2d.PbVec2 center = 10;
inline bool PbShape::has_center() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbShape::set_has_center() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbShape::clear_has_center() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbShape::clear_center() {
  if (center_ != NULL) center_->::box2d::PbVec2::Clear();
  clear_has_center();
}
inline const ::box2d::PbVec2& PbShape::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::box2d::PbVec2* PbShape::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::box2d::PbVec2;
  return center_;
}
inline ::box2d::PbVec2* PbShape::release_center() {
  clear_has_center();
  ::box2d::PbVec2* temp = center_;
  center_ = NULL;
  return temp;
}
inline void PbShape::set_allocated_center(::box2d::PbVec2* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
}

// optional float radius = 11;
inline bool PbShape::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbShape::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbShape::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbShape::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float PbShape::radius() const {
  return radius_;
}
inline void PbShape::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// repeated .box2d.PbVec2 points = 20;
inline int PbShape::points_size() const {
  return points_.size();
}
inline void PbShape::clear_points() {
  points_.Clear();
}
inline const ::box2d::PbVec2& PbShape::points(int index) const {
  return points_.Get(index);
}
inline ::box2d::PbVec2* PbShape::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::box2d::PbVec2* PbShape::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
PbShape::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
PbShape::mutable_points() {
  return &points_;
}

// repeated .box2d.PbVec2 normals = 21;
inline int PbShape::normals_size() const {
  return normals_.size();
}
inline void PbShape::clear_normals() {
  normals_.Clear();
}
inline const ::box2d::PbVec2& PbShape::normals(int index) const {
  return normals_.Get(index);
}
inline ::box2d::PbVec2* PbShape::mutable_normals(int index) {
  return normals_.Mutable(index);
}
inline ::box2d::PbVec2* PbShape::add_normals() {
  return normals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >&
PbShape::normals() const {
  return normals_;
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbVec2 >*
PbShape::mutable_normals() {
  return &normals_;
}

// optional .box2d.PbVec2 centroid = 22;
inline bool PbShape::has_centroid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbShape::set_has_centroid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbShape::clear_has_centroid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbShape::clear_centroid() {
  if (centroid_ != NULL) centroid_->::box2d::PbVec2::Clear();
  clear_has_centroid();
}
inline const ::box2d::PbVec2& PbShape::centroid() const {
  return centroid_ != NULL ? *centroid_ : *default_instance_->centroid_;
}
inline ::box2d::PbVec2* PbShape::mutable_centroid() {
  set_has_centroid();
  if (centroid_ == NULL) centroid_ = new ::box2d::PbVec2;
  return centroid_;
}
inline ::box2d::PbVec2* PbShape::release_centroid() {
  clear_has_centroid();
  ::box2d::PbVec2* temp = centroid_;
  centroid_ = NULL;
  return temp;
}
inline void PbShape::set_allocated_centroid(::box2d::PbVec2* centroid) {
  delete centroid_;
  centroid_ = centroid;
  if (centroid) {
    set_has_centroid();
  } else {
    clear_has_centroid();
  }
}

// -------------------------------------------------------------------

// PbFixture

// optional int64 tag = 1;
inline bool PbFixture::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbFixture::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbFixture::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbFixture::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbFixture::tag() const {
  return tag_;
}
inline void PbFixture::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
}

// optional float restitution = 2;
inline bool PbFixture::has_restitution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbFixture::set_has_restitution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbFixture::clear_has_restitution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbFixture::clear_restitution() {
  restitution_ = 0;
  clear_has_restitution();
}
inline float PbFixture::restitution() const {
  return restitution_;
}
inline void PbFixture::set_restitution(float value) {
  set_has_restitution();
  restitution_ = value;
}

// optional float friction = 3;
inline bool PbFixture::has_friction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbFixture::set_has_friction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbFixture::clear_has_friction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbFixture::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
inline float PbFixture::friction() const {
  return friction_;
}
inline void PbFixture::set_friction(float value) {
  set_has_friction();
  friction_ = value;
}

// optional float density = 4;
inline bool PbFixture::has_density() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbFixture::set_has_density() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbFixture::clear_has_density() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbFixture::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float PbFixture::density() const {
  return density_;
}
inline void PbFixture::set_density(float value) {
  set_has_density();
  density_ = value;
}

// optional bool sensor = 5;
inline bool PbFixture::has_sensor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbFixture::set_has_sensor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbFixture::clear_has_sensor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbFixture::clear_sensor() {
  sensor_ = false;
  clear_has_sensor();
}
inline bool PbFixture::sensor() const {
  return sensor_;
}
inline void PbFixture::set_sensor(bool value) {
  set_has_sensor();
  sensor_ = value;
}

// optional .box2d.PbFilter filter = 10;
inline bool PbFixture::has_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbFixture::set_has_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbFixture::clear_has_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbFixture::clear_filter() {
  if (filter_ != NULL) filter_->::box2d::PbFilter::Clear();
  clear_has_filter();
}
inline const ::box2d::PbFilter& PbFixture::filter() const {
  return filter_ != NULL ? *filter_ : *default_instance_->filter_;
}
inline ::box2d::PbFilter* PbFixture::mutable_filter() {
  set_has_filter();
  if (filter_ == NULL) filter_ = new ::box2d::PbFilter;
  return filter_;
}
inline ::box2d::PbFilter* PbFixture::release_filter() {
  clear_has_filter();
  ::box2d::PbFilter* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline void PbFixture::set_allocated_filter(::box2d::PbFilter* filter) {
  delete filter_;
  filter_ = filter;
  if (filter) {
    set_has_filter();
  } else {
    clear_has_filter();
  }
}

// optional .box2d.PbShape shape = 11;
inline bool PbFixture::has_shape() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbFixture::set_has_shape() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbFixture::clear_has_shape() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbFixture::clear_shape() {
  if (shape_ != NULL) shape_->::box2d::PbShape::Clear();
  clear_has_shape();
}
inline const ::box2d::PbShape& PbFixture::shape() const {
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
inline ::box2d::PbShape* PbFixture::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) shape_ = new ::box2d::PbShape;
  return shape_;
}
inline ::box2d::PbShape* PbFixture::release_shape() {
  clear_has_shape();
  ::box2d::PbShape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void PbFixture::set_allocated_shape(::box2d::PbShape* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    set_has_shape();
  } else {
    clear_has_shape();
  }
}

// -------------------------------------------------------------------

// PbJoint

// optional int64 tag = 1;
inline bool PbJoint::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbJoint::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbJoint::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbJoint::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbJoint::tag() const {
  return tag_;
}
inline void PbJoint::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
}

// required .box2d.PbJointType type = 2;
inline bool PbJoint::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbJoint::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbJoint::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbJoint::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::box2d::PbJointType PbJoint::type() const {
  return static_cast< ::box2d::PbJointType >(type_);
}
inline void PbJoint::set_type(::box2d::PbJointType value) {
  assert(::box2d::PbJointType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 body_a = 3;
inline bool PbJoint::has_body_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbJoint::set_has_body_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbJoint::clear_has_body_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbJoint::clear_body_a() {
  body_a_ = 0;
  clear_has_body_a();
}
inline ::google::protobuf::int32 PbJoint::body_a() const {
  return body_a_;
}
inline void PbJoint::set_body_a(::google::protobuf::int32 value) {
  set_has_body_a();
  body_a_ = value;
}

// optional int32 body_b = 4;
inline bool PbJoint::has_body_b() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbJoint::set_has_body_b() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbJoint::clear_has_body_b() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbJoint::clear_body_b() {
  body_b_ = 0;
  clear_has_body_b();
}
inline ::google::protobuf::int32 PbJoint::body_b() const {
  return body_b_;
}
inline void PbJoint::set_body_b(::google::protobuf::int32 value) {
  set_has_body_b();
  body_b_ = value;
}

// optional bool collideConnected = 5;
inline bool PbJoint::has_collideconnected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbJoint::set_has_collideconnected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbJoint::clear_has_collideconnected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbJoint::clear_collideconnected() {
  collideconnected_ = false;
  clear_has_collideconnected();
}
inline bool PbJoint::collideconnected() const {
  return collideconnected_;
}
inline void PbJoint::set_collideconnected(bool value) {
  set_has_collideconnected();
  collideconnected_ = value;
}

// optional .box2d.PbVec2 local_anchor_a = 6;
inline bool PbJoint::has_local_anchor_a() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbJoint::set_has_local_anchor_a() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbJoint::clear_has_local_anchor_a() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbJoint::clear_local_anchor_a() {
  if (local_anchor_a_ != NULL) local_anchor_a_->::box2d::PbVec2::Clear();
  clear_has_local_anchor_a();
}
inline const ::box2d::PbVec2& PbJoint::local_anchor_a() const {
  return local_anchor_a_ != NULL ? *local_anchor_a_ : *default_instance_->local_anchor_a_;
}
inline ::box2d::PbVec2* PbJoint::mutable_local_anchor_a() {
  set_has_local_anchor_a();
  if (local_anchor_a_ == NULL) local_anchor_a_ = new ::box2d::PbVec2;
  return local_anchor_a_;
}
inline ::box2d::PbVec2* PbJoint::release_local_anchor_a() {
  clear_has_local_anchor_a();
  ::box2d::PbVec2* temp = local_anchor_a_;
  local_anchor_a_ = NULL;
  return temp;
}
inline void PbJoint::set_allocated_local_anchor_a(::box2d::PbVec2* local_anchor_a) {
  delete local_anchor_a_;
  local_anchor_a_ = local_anchor_a;
  if (local_anchor_a) {
    set_has_local_anchor_a();
  } else {
    clear_has_local_anchor_a();
  }
}

// optional .box2d.PbVec2 local_anchor_b = 7;
inline bool PbJoint::has_local_anchor_b() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbJoint::set_has_local_anchor_b() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbJoint::clear_has_local_anchor_b() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbJoint::clear_local_anchor_b() {
  if (local_anchor_b_ != NULL) local_anchor_b_->::box2d::PbVec2::Clear();
  clear_has_local_anchor_b();
}
inline const ::box2d::PbVec2& PbJoint::local_anchor_b() const {
  return local_anchor_b_ != NULL ? *local_anchor_b_ : *default_instance_->local_anchor_b_;
}
inline ::box2d::PbVec2* PbJoint::mutable_local_anchor_b() {
  set_has_local_anchor_b();
  if (local_anchor_b_ == NULL) local_anchor_b_ = new ::box2d::PbVec2;
  return local_anchor_b_;
}
inline ::box2d::PbVec2* PbJoint::release_local_anchor_b() {
  clear_has_local_anchor_b();
  ::box2d::PbVec2* temp = local_anchor_b_;
  local_anchor_b_ = NULL;
  return temp;
}
inline void PbJoint::set_allocated_local_anchor_b(::box2d::PbVec2* local_anchor_b) {
  delete local_anchor_b_;
  local_anchor_b_ = local_anchor_b;
  if (local_anchor_b) {
    set_has_local_anchor_b();
  } else {
    clear_has_local_anchor_b();
  }
}

// optional float ref_angle = 10;
inline bool PbJoint::has_ref_angle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PbJoint::set_has_ref_angle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PbJoint::clear_has_ref_angle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PbJoint::clear_ref_angle() {
  ref_angle_ = 0;
  clear_has_ref_angle();
}
inline float PbJoint::ref_angle() const {
  return ref_angle_;
}
inline void PbJoint::set_ref_angle(float value) {
  set_has_ref_angle();
  ref_angle_ = value;
}

// optional bool enable_limit = 12;
inline bool PbJoint::has_enable_limit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PbJoint::set_has_enable_limit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PbJoint::clear_has_enable_limit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PbJoint::clear_enable_limit() {
  enable_limit_ = false;
  clear_has_enable_limit();
}
inline bool PbJoint::enable_limit() const {
  return enable_limit_;
}
inline void PbJoint::set_enable_limit(bool value) {
  set_has_enable_limit();
  enable_limit_ = value;
}

// optional float lower_limit = 13;
inline bool PbJoint::has_lower_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PbJoint::set_has_lower_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PbJoint::clear_has_lower_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PbJoint::clear_lower_limit() {
  lower_limit_ = 0;
  clear_has_lower_limit();
}
inline float PbJoint::lower_limit() const {
  return lower_limit_;
}
inline void PbJoint::set_lower_limit(float value) {
  set_has_lower_limit();
  lower_limit_ = value;
}

// optional float upper_limit = 14;
inline bool PbJoint::has_upper_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PbJoint::set_has_upper_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PbJoint::clear_has_upper_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PbJoint::clear_upper_limit() {
  upper_limit_ = 0;
  clear_has_upper_limit();
}
inline float PbJoint::upper_limit() const {
  return upper_limit_;
}
inline void PbJoint::set_upper_limit(float value) {
  set_has_upper_limit();
  upper_limit_ = value;
}

// optional bool enable_motor = 15;
inline bool PbJoint::has_enable_motor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PbJoint::set_has_enable_motor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PbJoint::clear_has_enable_motor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PbJoint::clear_enable_motor() {
  enable_motor_ = false;
  clear_has_enable_motor();
}
inline bool PbJoint::enable_motor() const {
  return enable_motor_;
}
inline void PbJoint::set_enable_motor(bool value) {
  set_has_enable_motor();
  enable_motor_ = value;
}

// optional float motor_speed = 16;
inline bool PbJoint::has_motor_speed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PbJoint::set_has_motor_speed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PbJoint::clear_has_motor_speed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PbJoint::clear_motor_speed() {
  motor_speed_ = 0;
  clear_has_motor_speed();
}
inline float PbJoint::motor_speed() const {
  return motor_speed_;
}
inline void PbJoint::set_motor_speed(float value) {
  set_has_motor_speed();
  motor_speed_ = value;
}

// optional float max_motor_torque = 17;
inline bool PbJoint::has_max_motor_torque() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PbJoint::set_has_max_motor_torque() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PbJoint::clear_has_max_motor_torque() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PbJoint::clear_max_motor_torque() {
  max_motor_torque_ = 0;
  clear_has_max_motor_torque();
}
inline float PbJoint::max_motor_torque() const {
  return max_motor_torque_;
}
inline void PbJoint::set_max_motor_torque(float value) {
  set_has_max_motor_torque();
  max_motor_torque_ = value;
}

// optional .box2d.PbVec2 local_axis_a = 20;
inline bool PbJoint::has_local_axis_a() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PbJoint::set_has_local_axis_a() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PbJoint::clear_has_local_axis_a() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PbJoint::clear_local_axis_a() {
  if (local_axis_a_ != NULL) local_axis_a_->::box2d::PbVec2::Clear();
  clear_has_local_axis_a();
}
inline const ::box2d::PbVec2& PbJoint::local_axis_a() const {
  return local_axis_a_ != NULL ? *local_axis_a_ : *default_instance_->local_axis_a_;
}
inline ::box2d::PbVec2* PbJoint::mutable_local_axis_a() {
  set_has_local_axis_a();
  if (local_axis_a_ == NULL) local_axis_a_ = new ::box2d::PbVec2;
  return local_axis_a_;
}
inline ::box2d::PbVec2* PbJoint::release_local_axis_a() {
  clear_has_local_axis_a();
  ::box2d::PbVec2* temp = local_axis_a_;
  local_axis_a_ = NULL;
  return temp;
}
inline void PbJoint::set_allocated_local_axis_a(::box2d::PbVec2* local_axis_a) {
  delete local_axis_a_;
  local_axis_a_ = local_axis_a;
  if (local_axis_a) {
    set_has_local_axis_a();
  } else {
    clear_has_local_axis_a();
  }
}

// optional float max_motor_force = 21;
inline bool PbJoint::has_max_motor_force() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PbJoint::set_has_max_motor_force() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PbJoint::clear_has_max_motor_force() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PbJoint::clear_max_motor_force() {
  max_motor_force_ = 0;
  clear_has_max_motor_force();
}
inline float PbJoint::max_motor_force() const {
  return max_motor_force_;
}
inline void PbJoint::set_max_motor_force(float value) {
  set_has_max_motor_force();
  max_motor_force_ = value;
}

// optional float length = 30;
inline bool PbJoint::has_length() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PbJoint::set_has_length() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PbJoint::clear_has_length() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PbJoint::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float PbJoint::length() const {
  return length_;
}
inline void PbJoint::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional float frequency = 31;
inline bool PbJoint::has_frequency() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PbJoint::set_has_frequency() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PbJoint::clear_has_frequency() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PbJoint::clear_frequency() {
  frequency_ = 0;
  clear_has_frequency();
}
inline float PbJoint::frequency() const {
  return frequency_;
}
inline void PbJoint::set_frequency(float value) {
  set_has_frequency();
  frequency_ = value;
}

// optional float damping_ratio = 32;
inline bool PbJoint::has_damping_ratio() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PbJoint::set_has_damping_ratio() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PbJoint::clear_has_damping_ratio() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PbJoint::clear_damping_ratio() {
  damping_ratio_ = 0;
  clear_has_damping_ratio();
}
inline float PbJoint::damping_ratio() const {
  return damping_ratio_;
}
inline void PbJoint::set_damping_ratio(float value) {
  set_has_damping_ratio();
  damping_ratio_ = value;
}

// optional .box2d.PbVec2 ground_anchor_a = 40;
inline bool PbJoint::has_ground_anchor_a() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PbJoint::set_has_ground_anchor_a() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PbJoint::clear_has_ground_anchor_a() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PbJoint::clear_ground_anchor_a() {
  if (ground_anchor_a_ != NULL) ground_anchor_a_->::box2d::PbVec2::Clear();
  clear_has_ground_anchor_a();
}
inline const ::box2d::PbVec2& PbJoint::ground_anchor_a() const {
  return ground_anchor_a_ != NULL ? *ground_anchor_a_ : *default_instance_->ground_anchor_a_;
}
inline ::box2d::PbVec2* PbJoint::mutable_ground_anchor_a() {
  set_has_ground_anchor_a();
  if (ground_anchor_a_ == NULL) ground_anchor_a_ = new ::box2d::PbVec2;
  return ground_anchor_a_;
}
inline ::box2d::PbVec2* PbJoint::release_ground_anchor_a() {
  clear_has_ground_anchor_a();
  ::box2d::PbVec2* temp = ground_anchor_a_;
  ground_anchor_a_ = NULL;
  return temp;
}
inline void PbJoint::set_allocated_ground_anchor_a(::box2d::PbVec2* ground_anchor_a) {
  delete ground_anchor_a_;
  ground_anchor_a_ = ground_anchor_a;
  if (ground_anchor_a) {
    set_has_ground_anchor_a();
  } else {
    clear_has_ground_anchor_a();
  }
}

// optional .box2d.PbVec2 ground_anchor_b = 41;
inline bool PbJoint::has_ground_anchor_b() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PbJoint::set_has_ground_anchor_b() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PbJoint::clear_has_ground_anchor_b() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PbJoint::clear_ground_anchor_b() {
  if (ground_anchor_b_ != NULL) ground_anchor_b_->::box2d::PbVec2::Clear();
  clear_has_ground_anchor_b();
}
inline const ::box2d::PbVec2& PbJoint::ground_anchor_b() const {
  return ground_anchor_b_ != NULL ? *ground_anchor_b_ : *default_instance_->ground_anchor_b_;
}
inline ::box2d::PbVec2* PbJoint::mutable_ground_anchor_b() {
  set_has_ground_anchor_b();
  if (ground_anchor_b_ == NULL) ground_anchor_b_ = new ::box2d::PbVec2;
  return ground_anchor_b_;
}
inline ::box2d::PbVec2* PbJoint::release_ground_anchor_b() {
  clear_has_ground_anchor_b();
  ::box2d::PbVec2* temp = ground_anchor_b_;
  ground_anchor_b_ = NULL;
  return temp;
}
inline void PbJoint::set_allocated_ground_anchor_b(::box2d::PbVec2* ground_anchor_b) {
  delete ground_anchor_b_;
  ground_anchor_b_ = ground_anchor_b;
  if (ground_anchor_b) {
    set_has_ground_anchor_b();
  } else {
    clear_has_ground_anchor_b();
  }
}

// optional float length_a = 42;
inline bool PbJoint::has_length_a() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PbJoint::set_has_length_a() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PbJoint::clear_has_length_a() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PbJoint::clear_length_a() {
  length_a_ = 0;
  clear_has_length_a();
}
inline float PbJoint::length_a() const {
  return length_a_;
}
inline void PbJoint::set_length_a(float value) {
  set_has_length_a();
  length_a_ = value;
}

// optional float length_b = 43;
inline bool PbJoint::has_length_b() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PbJoint::set_has_length_b() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PbJoint::clear_has_length_b() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PbJoint::clear_length_b() {
  length_b_ = 0;
  clear_has_length_b();
}
inline float PbJoint::length_b() const {
  return length_b_;
}
inline void PbJoint::set_length_b(float value) {
  set_has_length_b();
  length_b_ = value;
}

// optional float ratio = 44;
inline bool PbJoint::has_ratio() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PbJoint::set_has_ratio() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PbJoint::clear_has_ratio() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PbJoint::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline float PbJoint::ratio() const {
  return ratio_;
}
inline void PbJoint::set_ratio(float value) {
  set_has_ratio();
  ratio_ = value;
}

// optional float max_length_a = 45;
inline bool PbJoint::has_max_length_a() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PbJoint::set_has_max_length_a() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PbJoint::clear_has_max_length_a() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PbJoint::clear_max_length_a() {
  max_length_a_ = 0;
  clear_has_max_length_a();
}
inline float PbJoint::max_length_a() const {
  return max_length_a_;
}
inline void PbJoint::set_max_length_a(float value) {
  set_has_max_length_a();
  max_length_a_ = value;
}

// optional float max_length_b = 46;
inline bool PbJoint::has_max_length_b() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PbJoint::set_has_max_length_b() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PbJoint::clear_has_max_length_b() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PbJoint::clear_max_length_b() {
  max_length_b_ = 0;
  clear_has_max_length_b();
}
inline float PbJoint::max_length_b() const {
  return max_length_b_;
}
inline void PbJoint::set_max_length_b(float value) {
  set_has_max_length_b();
  max_length_b_ = value;
}

// optional .box2d.PbVec2 target = 50;
inline bool PbJoint::has_target() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PbJoint::set_has_target() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PbJoint::clear_has_target() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PbJoint::clear_target() {
  if (target_ != NULL) target_->::box2d::PbVec2::Clear();
  clear_has_target();
}
inline const ::box2d::PbVec2& PbJoint::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::box2d::PbVec2* PbJoint::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::box2d::PbVec2;
  return target_;
}
inline ::box2d::PbVec2* PbJoint::release_target() {
  clear_has_target();
  ::box2d::PbVec2* temp = target_;
  target_ = NULL;
  return temp;
}
inline void PbJoint::set_allocated_target(::box2d::PbVec2* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// optional float max_force = 51;
inline bool PbJoint::has_max_force() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PbJoint::set_has_max_force() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PbJoint::clear_has_max_force() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PbJoint::clear_max_force() {
  max_force_ = 0;
  clear_has_max_force();
}
inline float PbJoint::max_force() const {
  return max_force_;
}
inline void PbJoint::set_max_force(float value) {
  set_has_max_force();
  max_force_ = value;
}

// optional int32 joint1 = 61;
inline bool PbJoint::has_joint1() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PbJoint::set_has_joint1() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PbJoint::clear_has_joint1() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PbJoint::clear_joint1() {
  joint1_ = 0;
  clear_has_joint1();
}
inline ::google::protobuf::int32 PbJoint::joint1() const {
  return joint1_;
}
inline void PbJoint::set_joint1(::google::protobuf::int32 value) {
  set_has_joint1();
  joint1_ = value;
}

// optional int32 joint2 = 62;
inline bool PbJoint::has_joint2() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PbJoint::set_has_joint2() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PbJoint::clear_has_joint2() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PbJoint::clear_joint2() {
  joint2_ = 0;
  clear_has_joint2();
}
inline ::google::protobuf::int32 PbJoint::joint2() const {
  return joint2_;
}
inline void PbJoint::set_joint2(::google::protobuf::int32 value) {
  set_has_joint2();
  joint2_ = value;
}

// optional float spring_frequency = 70;
inline bool PbJoint::has_spring_frequency() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PbJoint::set_has_spring_frequency() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PbJoint::clear_has_spring_frequency() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PbJoint::clear_spring_frequency() {
  spring_frequency_ = 0;
  clear_has_spring_frequency();
}
inline float PbJoint::spring_frequency() const {
  return spring_frequency_;
}
inline void PbJoint::set_spring_frequency(float value) {
  set_has_spring_frequency();
  spring_frequency_ = value;
}

// optional float spring_damping_ratio = 71;
inline bool PbJoint::has_spring_damping_ratio() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PbJoint::set_has_spring_damping_ratio() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PbJoint::clear_has_spring_damping_ratio() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PbJoint::clear_spring_damping_ratio() {
  spring_damping_ratio_ = 0;
  clear_has_spring_damping_ratio();
}
inline float PbJoint::spring_damping_ratio() const {
  return spring_damping_ratio_;
}
inline void PbJoint::set_spring_damping_ratio(float value) {
  set_has_spring_damping_ratio();
  spring_damping_ratio_ = value;
}

// optional float max_torque = 90;
inline bool PbJoint::has_max_torque() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PbJoint::set_has_max_torque() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PbJoint::clear_has_max_torque() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PbJoint::clear_max_torque() {
  max_torque_ = 0;
  clear_has_max_torque();
}
inline float PbJoint::max_torque() const {
  return max_torque_;
}
inline void PbJoint::set_max_torque(float value) {
  set_has_max_torque();
  max_torque_ = value;
}

// optional float max_length = 100;
inline bool PbJoint::has_max_length() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PbJoint::set_has_max_length() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PbJoint::clear_has_max_length() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PbJoint::clear_max_length() {
  max_length_ = 0;
  clear_has_max_length();
}
inline float PbJoint::max_length() const {
  return max_length_;
}
inline void PbJoint::set_max_length(float value) {
  set_has_max_length();
  max_length_ = value;
}

// repeated int32 bodies = 110;
inline int PbJoint::bodies_size() const {
  return bodies_.size();
}
inline void PbJoint::clear_bodies() {
  bodies_.Clear();
}
inline ::google::protobuf::int32 PbJoint::bodies(int index) const {
  return bodies_.Get(index);
}
inline void PbJoint::set_bodies(int index, ::google::protobuf::int32 value) {
  bodies_.Set(index, value);
}
inline void PbJoint::add_bodies(::google::protobuf::int32 value) {
  bodies_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PbJoint::bodies() const {
  return bodies_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PbJoint::mutable_bodies() {
  return &bodies_;
}

// repeated int32 joints = 111;
inline int PbJoint::joints_size() const {
  return joints_.size();
}
inline void PbJoint::clear_joints() {
  joints_.Clear();
}
inline ::google::protobuf::int32 PbJoint::joints(int index) const {
  return joints_.Get(index);
}
inline void PbJoint::set_joints(int index, ::google::protobuf::int32 value) {
  joints_.Set(index, value);
}
inline void PbJoint::add_joints(::google::protobuf::int32 value) {
  joints_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PbJoint::joints() const {
  return joints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PbJoint::mutable_joints() {
  return &joints_;
}

// optional float target_volume = 112;
inline bool PbJoint::has_target_volume() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PbJoint::set_has_target_volume() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PbJoint::clear_has_target_volume() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PbJoint::clear_target_volume() {
  target_volume_ = 0;
  clear_has_target_volume();
}
inline float PbJoint::target_volume() const {
  return target_volume_;
}
inline void PbJoint::set_target_volume(float value) {
  set_has_target_volume();
  target_volume_ = value;
}

// -------------------------------------------------------------------

// PbBody

// optional int64 tag = 1;
inline bool PbBody::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbBody::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbBody::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbBody::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbBody::tag() const {
  return tag_;
}
inline void PbBody::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
}

// required .box2d.PbBodyType type = 2;
inline bool PbBody::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbBody::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbBody::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbBody::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::box2d::PbBodyType PbBody::type() const {
  return static_cast< ::box2d::PbBodyType >(type_);
}
inline void PbBody::set_type(::box2d::PbBodyType value) {
  assert(::box2d::PbBodyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .box2d.PbVec2 position = 10;
inline bool PbBody::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbBody::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbBody::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbBody::clear_position() {
  if (position_ != NULL) position_->::box2d::PbVec2::Clear();
  clear_has_position();
}
inline const ::box2d::PbVec2& PbBody::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::box2d::PbVec2* PbBody::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::box2d::PbVec2;
  return position_;
}
inline ::box2d::PbVec2* PbBody::release_position() {
  clear_has_position();
  ::box2d::PbVec2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PbBody::set_allocated_position(::box2d::PbVec2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional float angle = 11;
inline bool PbBody::has_angle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbBody::set_has_angle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbBody::clear_has_angle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbBody::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float PbBody::angle() const {
  return angle_;
}
inline void PbBody::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional .box2d.PbVec2 linear_velocity = 12;
inline bool PbBody::has_linear_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbBody::set_has_linear_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbBody::clear_has_linear_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbBody::clear_linear_velocity() {
  if (linear_velocity_ != NULL) linear_velocity_->::box2d::PbVec2::Clear();
  clear_has_linear_velocity();
}
inline const ::box2d::PbVec2& PbBody::linear_velocity() const {
  return linear_velocity_ != NULL ? *linear_velocity_ : *default_instance_->linear_velocity_;
}
inline ::box2d::PbVec2* PbBody::mutable_linear_velocity() {
  set_has_linear_velocity();
  if (linear_velocity_ == NULL) linear_velocity_ = new ::box2d::PbVec2;
  return linear_velocity_;
}
inline ::box2d::PbVec2* PbBody::release_linear_velocity() {
  clear_has_linear_velocity();
  ::box2d::PbVec2* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline void PbBody::set_allocated_linear_velocity(::box2d::PbVec2* linear_velocity) {
  delete linear_velocity_;
  linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    set_has_linear_velocity();
  } else {
    clear_has_linear_velocity();
  }
}

// optional float angular_velocity = 13;
inline bool PbBody::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbBody::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbBody::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbBody::clear_angular_velocity() {
  angular_velocity_ = 0;
  clear_has_angular_velocity();
}
inline float PbBody::angular_velocity() const {
  return angular_velocity_;
}
inline void PbBody::set_angular_velocity(float value) {
  set_has_angular_velocity();
  angular_velocity_ = value;
}

// optional .box2d.PbVec2 force = 14;
inline bool PbBody::has_force() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbBody::set_has_force() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbBody::clear_has_force() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbBody::clear_force() {
  if (force_ != NULL) force_->::box2d::PbVec2::Clear();
  clear_has_force();
}
inline const ::box2d::PbVec2& PbBody::force() const {
  return force_ != NULL ? *force_ : *default_instance_->force_;
}
inline ::box2d::PbVec2* PbBody::mutable_force() {
  set_has_force();
  if (force_ == NULL) force_ = new ::box2d::PbVec2;
  return force_;
}
inline ::box2d::PbVec2* PbBody::release_force() {
  clear_has_force();
  ::box2d::PbVec2* temp = force_;
  force_ = NULL;
  return temp;
}
inline void PbBody::set_allocated_force(::box2d::PbVec2* force) {
  delete force_;
  force_ = force;
  if (force) {
    set_has_force();
  } else {
    clear_has_force();
  }
}

// optional float torque = 15;
inline bool PbBody::has_torque() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PbBody::set_has_torque() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PbBody::clear_has_torque() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PbBody::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline float PbBody::torque() const {
  return torque_;
}
inline void PbBody::set_torque(float value) {
  set_has_torque();
  torque_ = value;
}

// optional float mass = 16;
inline bool PbBody::has_mass() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PbBody::set_has_mass() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PbBody::clear_has_mass() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PbBody::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float PbBody::mass() const {
  return mass_;
}
inline void PbBody::set_mass(float value) {
  set_has_mass();
  mass_ = value;
}

// optional float I = 17;
inline bool PbBody::has_i() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PbBody::set_has_i() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PbBody::clear_has_i() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PbBody::clear_i() {
  i_ = 0;
  clear_has_i();
}
inline float PbBody::i() const {
  return i_;
}
inline void PbBody::set_i(float value) {
  set_has_i();
  i_ = value;
}

// optional float linear_damping = 50;
inline bool PbBody::has_linear_damping() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PbBody::set_has_linear_damping() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PbBody::clear_has_linear_damping() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PbBody::clear_linear_damping() {
  linear_damping_ = 0;
  clear_has_linear_damping();
}
inline float PbBody::linear_damping() const {
  return linear_damping_;
}
inline void PbBody::set_linear_damping(float value) {
  set_has_linear_damping();
  linear_damping_ = value;
}

// optional float angular_damping = 51;
inline bool PbBody::has_angular_damping() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PbBody::set_has_angular_damping() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PbBody::clear_has_angular_damping() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PbBody::clear_angular_damping() {
  angular_damping_ = 0;
  clear_has_angular_damping();
}
inline float PbBody::angular_damping() const {
  return angular_damping_;
}
inline void PbBody::set_angular_damping(float value) {
  set_has_angular_damping();
  angular_damping_ = value;
}

// optional float gravity_scale = 52;
inline bool PbBody::has_gravity_scale() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PbBody::set_has_gravity_scale() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PbBody::clear_has_gravity_scale() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PbBody::clear_gravity_scale() {
  gravity_scale_ = 0;
  clear_has_gravity_scale();
}
inline float PbBody::gravity_scale() const {
  return gravity_scale_;
}
inline void PbBody::set_gravity_scale(float value) {
  set_has_gravity_scale();
  gravity_scale_ = value;
}

// optional bool bullet = 53;
inline bool PbBody::has_bullet() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PbBody::set_has_bullet() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PbBody::clear_has_bullet() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PbBody::clear_bullet() {
  bullet_ = false;
  clear_has_bullet();
}
inline bool PbBody::bullet() const {
  return bullet_;
}
inline void PbBody::set_bullet(bool value) {
  set_has_bullet();
  bullet_ = value;
}

// optional bool allow_sleep = 54;
inline bool PbBody::has_allow_sleep() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PbBody::set_has_allow_sleep() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PbBody::clear_has_allow_sleep() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PbBody::clear_allow_sleep() {
  allow_sleep_ = false;
  clear_has_allow_sleep();
}
inline bool PbBody::allow_sleep() const {
  return allow_sleep_;
}
inline void PbBody::set_allow_sleep(bool value) {
  set_has_allow_sleep();
  allow_sleep_ = value;
}

// optional bool awake = 55;
inline bool PbBody::has_awake() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PbBody::set_has_awake() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PbBody::clear_has_awake() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PbBody::clear_awake() {
  awake_ = false;
  clear_has_awake();
}
inline bool PbBody::awake() const {
  return awake_;
}
inline void PbBody::set_awake(bool value) {
  set_has_awake();
  awake_ = value;
}

// optional bool active = 56;
inline bool PbBody::has_active() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PbBody::set_has_active() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PbBody::clear_has_active() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PbBody::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool PbBody::active() const {
  return active_;
}
inline void PbBody::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional bool fixed_rotation = 57;
inline bool PbBody::has_fixed_rotation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PbBody::set_has_fixed_rotation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PbBody::clear_has_fixed_rotation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PbBody::clear_fixed_rotation() {
  fixed_rotation_ = false;
  clear_has_fixed_rotation();
}
inline bool PbBody::fixed_rotation() const {
  return fixed_rotation_;
}
inline void PbBody::set_fixed_rotation(bool value) {
  set_has_fixed_rotation();
  fixed_rotation_ = value;
}

// repeated .box2d.PbFixture fixtures = 100;
inline int PbBody::fixtures_size() const {
  return fixtures_.size();
}
inline void PbBody::clear_fixtures() {
  fixtures_.Clear();
}
inline const ::box2d::PbFixture& PbBody::fixtures(int index) const {
  return fixtures_.Get(index);
}
inline ::box2d::PbFixture* PbBody::mutable_fixtures(int index) {
  return fixtures_.Mutable(index);
}
inline ::box2d::PbFixture* PbBody::add_fixtures() {
  return fixtures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >&
PbBody::fixtures() const {
  return fixtures_;
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbFixture >*
PbBody::mutable_fixtures() {
  return &fixtures_;
}

// -------------------------------------------------------------------

// PbWorld

// optional int64 tag = 1;
inline bool PbWorld::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbWorld::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbWorld::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbWorld::clear_tag() {
  tag_ = GOOGLE_LONGLONG(0);
  clear_has_tag();
}
inline ::google::protobuf::int64 PbWorld::tag() const {
  return tag_;
}
inline void PbWorld::set_tag(::google::protobuf::int64 value) {
  set_has_tag();
  tag_ = value;
}

// optional .box2d.PbVec2 gravity = 2;
inline bool PbWorld::has_gravity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbWorld::set_has_gravity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbWorld::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbWorld::clear_gravity() {
  if (gravity_ != NULL) gravity_->::box2d::PbVec2::Clear();
  clear_has_gravity();
}
inline const ::box2d::PbVec2& PbWorld::gravity() const {
  return gravity_ != NULL ? *gravity_ : *default_instance_->gravity_;
}
inline ::box2d::PbVec2* PbWorld::mutable_gravity() {
  set_has_gravity();
  if (gravity_ == NULL) gravity_ = new ::box2d::PbVec2;
  return gravity_;
}
inline ::box2d::PbVec2* PbWorld::release_gravity() {
  clear_has_gravity();
  ::box2d::PbVec2* temp = gravity_;
  gravity_ = NULL;
  return temp;
}
inline void PbWorld::set_allocated_gravity(::box2d::PbVec2* gravity) {
  delete gravity_;
  gravity_ = gravity;
  if (gravity) {
    set_has_gravity();
  } else {
    clear_has_gravity();
  }
}

// optional bool allow_sleep = 3;
inline bool PbWorld::has_allow_sleep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbWorld::set_has_allow_sleep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbWorld::clear_has_allow_sleep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbWorld::clear_allow_sleep() {
  allow_sleep_ = false;
  clear_has_allow_sleep();
}
inline bool PbWorld::allow_sleep() const {
  return allow_sleep_;
}
inline void PbWorld::set_allow_sleep(bool value) {
  set_has_allow_sleep();
  allow_sleep_ = value;
}

// optional bool auto_clear_forces = 4;
inline bool PbWorld::has_auto_clear_forces() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbWorld::set_has_auto_clear_forces() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbWorld::clear_has_auto_clear_forces() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbWorld::clear_auto_clear_forces() {
  auto_clear_forces_ = false;
  clear_has_auto_clear_forces();
}
inline bool PbWorld::auto_clear_forces() const {
  return auto_clear_forces_;
}
inline void PbWorld::set_auto_clear_forces(bool value) {
  set_has_auto_clear_forces();
  auto_clear_forces_ = value;
}

// optional bool warm_starting = 5;
inline bool PbWorld::has_warm_starting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbWorld::set_has_warm_starting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbWorld::clear_has_warm_starting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbWorld::clear_warm_starting() {
  warm_starting_ = false;
  clear_has_warm_starting();
}
inline bool PbWorld::warm_starting() const {
  return warm_starting_;
}
inline void PbWorld::set_warm_starting(bool value) {
  set_has_warm_starting();
  warm_starting_ = value;
}

// optional bool continuous_physics = 6;
inline bool PbWorld::has_continuous_physics() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbWorld::set_has_continuous_physics() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbWorld::clear_has_continuous_physics() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbWorld::clear_continuous_physics() {
  continuous_physics_ = false;
  clear_has_continuous_physics();
}
inline bool PbWorld::continuous_physics() const {
  return continuous_physics_;
}
inline void PbWorld::set_continuous_physics(bool value) {
  set_has_continuous_physics();
  continuous_physics_ = value;
}

// optional bool sub_stepping = 7;
inline bool PbWorld::has_sub_stepping() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbWorld::set_has_sub_stepping() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbWorld::clear_has_sub_stepping() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbWorld::clear_sub_stepping() {
  sub_stepping_ = false;
  clear_has_sub_stepping();
}
inline bool PbWorld::sub_stepping() const {
  return sub_stepping_;
}
inline void PbWorld::set_sub_stepping(bool value) {
  set_has_sub_stepping();
  sub_stepping_ = value;
}

// repeated .box2d.PbBody bodies = 20;
inline int PbWorld::bodies_size() const {
  return bodies_.size();
}
inline void PbWorld::clear_bodies() {
  bodies_.Clear();
}
inline const ::box2d::PbBody& PbWorld::bodies(int index) const {
  return bodies_.Get(index);
}
inline ::box2d::PbBody* PbWorld::mutable_bodies(int index) {
  return bodies_.Mutable(index);
}
inline ::box2d::PbBody* PbWorld::add_bodies() {
  return bodies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >&
PbWorld::bodies() const {
  return bodies_;
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbBody >*
PbWorld::mutable_bodies() {
  return &bodies_;
}

// repeated .box2d.PbJoint joints = 21;
inline int PbWorld::joints_size() const {
  return joints_.size();
}
inline void PbWorld::clear_joints() {
  joints_.Clear();
}
inline const ::box2d::PbJoint& PbWorld::joints(int index) const {
  return joints_.Get(index);
}
inline ::box2d::PbJoint* PbWorld::mutable_joints(int index) {
  return joints_.Mutable(index);
}
inline ::box2d::PbJoint* PbWorld::add_joints() {
  return joints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >&
PbWorld::joints() const {
  return joints_;
}
inline ::google::protobuf::RepeatedPtrField< ::box2d::PbJoint >*
PbWorld::mutable_joints() {
  return &joints_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace box2d

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::box2d::PbBodyType>() {
  return ::box2d::PbBodyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::box2d::PbShapeType>() {
  return ::box2d::PbShapeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::box2d::PbJointType>() {
  return ::box2d::PbJointType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_box2d_2eproto__INCLUDED
